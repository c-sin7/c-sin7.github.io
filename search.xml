<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ASM</title>
      <link href="/2023/02/10/ASM/"/>
      <url>/2023/02/10/ASM/</url>
      
        <content type="html"><![CDATA[<h3 id="2-2-INT-21H的1号功能，输入一个字符串”Hello-world”-存放在内存，然后倒序输出"><a href="#2-2-INT-21H的1号功能，输入一个字符串”Hello-world”-存放在内存，然后倒序输出" class="headerlink" title="2.2 INT 21H的1号功能，输入一个字符串”Hello,world”,存放在内存，然后倒序输出"></a>2.2 INT 21H的1号功能，输入一个字符串”Hello,world”,存放在内存，然后倒序输出</h3><pre class=" language-ASM"><code class="language-ASM">;2.2 INT 21H的1号功能，输入一个字符串"Hello,world",存放在内存，然后倒序输出S1 SEGMENTS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    ;输入 cx作计数器    SUB CX,CXL1:     MOV AH,1    INT 21H    CMP AL,0DH    JE  L2    XOR AH,AH    PUSH AX    INC CX    JMP L1        ;输出L2:     POP DX    MOV AH,2    INT 21H    LOOP L2    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="2-3-INT-21H的A号功能，输入一个字符串”Hello-world”-存放在内存，然后倒序输出"><a href="#2-3-INT-21H的A号功能，输入一个字符串”Hello-world”-存放在内存，然后倒序输出" class="headerlink" title="2.3 INT 21H的A号功能，输入一个字符串”Hello,world”,存放在内存，然后倒序输出"></a>2.3 INT 21H的A号功能，输入一个字符串”Hello,world”,存放在内存，然后倒序输出</h3><pre class=" language-ASM"><code class="language-ASM">;2.3 INT 21H的A号功能，输入一个字符串"Hello,world",存放在内存，然后倒序输出S1 SEGMENT    BUFF DB 250,?,250 DUP(?)    SHOW DB 0DH,0AH,'THE REVERSE STRING IS:$'S1 ENDSS2 SEGMENT STACK    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    ;输入    MOV AH,0AH    INT 21H        MOV SI,DX    INC SI    MOV AL,DS:[SI]    ;真实数据总个数    CBW     MOV CX,AX        ;计数器    ADD SI,AX        ;串尾 不包括ODH        ;输出    LEA DX,SHOW    MOV AH,09H    INT 21HL0:        MOV DL,DS:[SI]    MOV AH,2    INT 21H    DEC SI    LOOP L0EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="3-1-将-BX-中的无符号数以二进制的形式输出"><a href="#3-1-将-BX-中的无符号数以二进制的形式输出" class="headerlink" title="3.1 将 BX 中的无符号数以二进制的形式输出"></a>3.1 将 BX 中的无符号数以二进制的形式输出</h3><pre class=" language-ASM"><code class="language-ASM">;3.1将 BX 中的无符号数以二进制的形式输出S1 SEGMENT    A DW 6C3BH  S1 ENDSS2 SEGMENT    DB 30 DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV CX,10H    MOV BX,AL0:     ROL BX,1    MOV DL,30H    ADC DL,0    MOV AH,2    INT 21H    LOOP L0EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="3-4-将BX的无符号数以十进制数形式输出"><a href="#3-4-将BX的无符号数以十进制数形式输出" class="headerlink" title="3.4 将BX的无符号数以十进制数形式输出"></a>3.4 将BX的无符号数以十进制数形式输出</h3><pre class=" language-ASM"><code class="language-ASM">;3.4 将 BX 中的无符号数以十进制的形式输出S1 SEGMENT    A DW 2A3BH    CNT DW 0S1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV BX,A    MOV AX,BX    MOV CX,0AH        ;转化并入栈    ;DX余数 AX商L0:    XOR DX,DX    DIV CX    PUSH DX        ;余数进栈    INC CNT    CMP AX,0    JNE L0        ;输出    MOV CX,CNTL1:        POP DX    ADD DX,30H    MOV AH,2    INT 21H    LOOP L1EXIT:       MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="3-5-将BX的有符号数以十进制数形式输出"><a href="#3-5-将BX的有符号数以十进制数形式输出" class="headerlink" title="3.5 将BX的有符号数以十进制数形式输出"></a>3.5 将BX的有符号数以十进制数形式输出</h3><pre class=" language-ASM"><code class="language-ASM">;3.5 将BX的有符号数以十进制数形式输出S1 SEGMENT    A DW 8000HS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV BX,A    MOV AX,BX    MOV DI,10    MOV CX,0        ;判断正负数    CMP AX,0    JGE L1        NEG AX    PUSH AX    MOV DL,'-'    MOV AH,2    INT 21H    POP AX    L0:    XOR DX,DX    IDIV DI    ;/10    PUSH DX    ;压余数    INC CX     ;记录除了几次    CMP AX,0   ;比较除完了没    JNE L0    L1:    POP DX    ADD DX,30H    MOV AH,2    INT 21H    LOOP L1EXIT:    MOV AH,4CH    INT 21H    MAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="4-2-输入两个字X-Y，计算Z-X-Y-并把Z的结果显示出来，X-Y的输入可以是任何进制"><a href="#4-2-输入两个字X-Y，计算Z-X-Y-并把Z的结果显示出来，X-Y的输入可以是任何进制" class="headerlink" title="4.2 输入两个字X,Y，计算Z=X+Y,并把Z的结果显示出来，X,Y的输入可以是任何进制"></a>4.2 输入两个字X,Y，计算Z=X+Y,并把Z的结果显示出来，X,Y的输入可以是任何进制</h3><pre class=" language-ASM"><code class="language-ASM">;4.2 输入两个字X,Y，计算Z=X+Y,并把Z的结果显示出来，X,Y的输入可以是任何进制S1 SEGMENT    X DW 0    Y DW 0    Z DW 0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV CX,16    XOR BX,BX        ;输入并放置在bxL0:     MOV AH,1    INT 21H    CMP AL,0DH    JE  L1    CMP AL,30H    JB L0    CMP AL,31H    JA L0    SHR AL,1    RCL BX,1    LOOP L0L1:    MOV X,BX    ;吸收回车    MOV AH,1    INT 21H          ;输入并放置在bxL2:     MOV AH,1    INT 21H    CMP AL,0DH    JE  L3    CMP AL,30H    JB L2    CMP AL,31H    JA L2    SHR AL,1    RCL BX,1    LOOP L2L3:    MOV Y,BX            ;两数相加    MOV DX,X    MOV BX,Y    ADD BX,DX    MOV CX,16L4:    ROL BX,1    MOV DX,30H    ADC DX,0    MOV AH,2    INT 21H    LOOP L4    EXIT:    MOV AH,4CH    INT 21H    MAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="4-3-输入一个有符号的十进制数，并以十六进制输出"><a href="#4-3-输入一个有符号的十进制数，并以十六进制输出" class="headerlink" title="4.3 输入一个有符号的十进制数，并以十六进制输出"></a>4.3 输入一个有符号的十进制数，并以十六进制输出</h3><pre class=" language-ASM"><code class="language-ASM">;4.3 输入一个有符号的十进制数，并以十六进制输出S1 SEGMENT    NUM DW 8000    F    DW 0S1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    XOR BX,BX    CALL READIN    CMP F,0    JNE    L3L3:    NEG BX    CALL CHANGE    EXIT:        MOV AH,4CH    INT 21HMAIN ENDPREADIN PROC NEAR    ;输入 判断正负L0:    MOV AH,1    INT 21H    CMP AL,0DH    JE  EXIT1    CMP AL,'-'    JNE L1    INC F    L1:    SUB AL,30H    JL  L0    CMP AL,9D    JG    L0    ;->10    CBW    XCHG AX,BX    MOV CX,10D    MUL CX    XCHG BX,AX    ADD BX,AX    JMP L0    EXIT1:    RET    READIN ENDPCHANGE PROC NEAR    ;10->16    MOV CX,4L2:    PUSH CX    MOV CL,4    ROL BX,CL    MOV DL,BL    AND DL,0FH    ADD DL,30H    CMP DL,39H    JBE DISP    ADD DL,7DISP:    MOV AH,2    INT 21H    POP CX    LOOP L2        RETCHANGE ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-1-试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来"><a href="#5-1-试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来" class="headerlink" title="5.1 试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来"></a>5.1 试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来</h3><pre class=" language-ASM"><code class="language-ASM">;5.1对键盘输入的小写字母用大写字母显示出来S1 SEGMENTS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP     ;输入小写L1:    MOV AH,1    INT 21H    CMP AL,'a'    JB L1    CMP AL,'z'    JA L1    MOV BL,AL        MOV DL,0DH    MOV AH,2    INT 21H    MOV DL,0AH    MOV AH,2    INT 21H        ;变大写输出    MOV DL,BL    SUB DL,20H    MOV AH,2    INT 21HEXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符"><a href="#5-2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符" class="headerlink" title="5.2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符"></a>5.2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符</h3><pre class=" language-ASM"><code class="language-ASM">;5.2接收一个小写字母，然后找出前导字符和后续字符，按顺序输出S1 SEGMENTS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP     ;输入L0:    MOV AH,1    INT 21H    CMP AL,'a'    JB L0    CMP AL,'z'    JA L0    MOV BL,AL    DEC BL        ;输出    MOV DL,0DH    MOV AH,2    INT 21H    MOV DL,0AH    MOV AH,2    INT 21H            MOV CX,2    MOV DL,BLL1:    MOV AH,2    INT 21H    ADD DL,2    LOOP L1EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-3将-AX-寄存器中的-16-位数分成-4-组，每组-4-位，然后把这四组数分别放在-AL、BL、CL-和-DL-中"><a href="#5-3将-AX-寄存器中的-16-位数分成-4-组，每组-4-位，然后把这四组数分别放在-AL、BL、CL-和-DL-中" class="headerlink" title="5.3将 AX 寄存器中的 16 位数分成 4 组，每组 4 位，然后把这四组数分别放在 AL、BL、CL 和 DL 中"></a>5.3将 AX 寄存器中的 16 位数分成 4 组，每组 4 位，然后把这四组数分别放在 AL、BL、CL 和 DL 中</h3><pre class=" language-ASM"><code class="language-ASM">;5.3将AX寄存器的16位数分为四组，每组四位，分别放在AL，BL，CL，DL中S1 SEGMENT    A1    DW    0    B1    DW    0    C1    DW    0    D1    DW    0S1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV AX,0ABCDH    MOV CL,4        ROL AX,CL    MOV BX,AX    AND BX,000FH    MOV SI,BX    ROL AX,CL    MOV BX,AX    AND BX,000FH    MOV DI,BX    ROL AX,CL    MOV BX,AX    AND BX,000FH    MOV BP,BX    ROL AX,CL    MOV BX,AX    AND BX,000FH    MOV DX,BX        MOV AX,SI    MOV BX,DI    MOV CX,BP        EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><pre class=" language-ASM"><code class="language-ASM">;5.3将AX寄存器的16位数分为四组，每组四位，分别放在AL，BL，CL，DL中S1 SEGMENTS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV AX,0ABCDH    PUSH AX        MOV CL,4    ROL AX,CL    PUSH AX    AND AX,000FH    POP BX    ROL BX,CL    PUSH BX    AND BX,000FH    POP CX    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    PUSH CX    AND CX,00F0H    POP DX    AND DX,000FH    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-4比较string1和string2所含字符是否相同，相同’MATCH’-不同’NOTMATCH’"><a href="#5-4比较string1和string2所含字符是否相同，相同’MATCH’-不同’NOTMATCH’" class="headerlink" title="5.4比较string1和string2所含字符是否相同，相同’MATCH’,不同’NOTMATCH’"></a>5.4比较string1和string2所含字符是否相同，相同’MATCH’,不同’NOTMATCH’</h3><pre class=" language-ASM"><code class="language-ASM">;5.4比较string1和string2所含字符是否相同，相同'MATCH',不同'NOTMATCH'S1 SEGMENT    STRING1 DB 'ABCDEFGH$'    STRING2 DB 'QQQQQQQQ$'    MATCH    DB 'MATCH$'    NOTMATCH    DB 'NOTMATCH$'S1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S2    MOV SS,AX    MOV AX,S1    MOV DS,AX    MOV ES,AX        LEA SI,STRING1    LEA DI,STRING2    MOV CX,8        CLD        REPNE CMPSB    JNE NO    YES:    LEA DX,MATCH    MOV AH,09H    INT 21H    JMP EXITNO:    LEA DX,NOTMATCH    MOV AH,09H    INT 21H    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-6将一个含有20个数据的数组M分成两个数组，"><a href="#5-6将一个含有20个数据的数组M分成两个数组，" class="headerlink" title="5.6将一个含有20个数据的数组M分成两个数组，"></a>5.6将一个含有20个数据的数组M分成两个数组，</h3><p>正数组P和负数组N,并分别把两个数组的数据的个数显示出来</p><pre class=" language-ASM"><code class="language-ASM">;5.6 将一个含有20个数据的数组M分成两个数组，;正数组P和负数组N,并分别把两个数组的数据的个数显示出来S1 SEGMENT    COUNT DB 20    M DW 1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,20    CNTP DW 0    P DW 20 DUP(?)    CNTN DW 0    N DW 20 DUP(?)    POST DB 0DH,0AH,'Positive:$'    NEGE DB 0DH,0AH,'Negative:$'    ENT DB 0DH,0AH,'$'S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV SI,0    MOV DI,0    MOV BP,0    MOV CX,20L0:     MOV BX,M[SI]    ADD SI,2    CMP BX,0    JS    L2        ;正数L1:     MOV P[DI],BX    INC CNTP    ADD DI,2    JMP L3        ;负数L2:     MOV N[BP],BX    INC CNTN    ADD BP,2    JMP L3L3:     LOOP L0            ;AH余数 AL商    MOV AX,CNTP    MOV BL,10    DIV BL    MOV BX,AX    LEA DX,POST    MOV AH,9    INT 21H    ADD BL,30H    MOV DL,BL    MOV AH,2    INT 21H    ADD BH,30H    MOV DL,BH    MOV AH,2    INT 21H        LEA DX,ENT    MOV AH,9    INT 21H        MOV AX,CNTN    MOV BL,10    DIV BL    MOV BX,AX    LEA DX,NEGE    MOV AH,9    INT 21H        ADD BL,30H    MOV DL,BL    MOV AH,2    INT 21H    ADD BH,30H    MOV DL,BH    MOV AH,2    INT 21H    EXIT:        MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-7-求出首地址为-DATA-的-100D-字数组中的最小偶数，并存放在-AX-中"><a href="#5-7-求出首地址为-DATA-的-100D-字数组中的最小偶数，并存放在-AX-中" class="headerlink" title="5.7 求出首地址为 DATA 的 100D 字数组中的最小偶数，并存放在 AX 中"></a>5.7 求出首地址为 DATA 的 100D 字数组中的最小偶数，并存放在 AX 中</h3><p>两次循环 前指针找出偶数放在ax 后指针找出偶数放在dx，假设ax是最小偶数，ax和dx进行比较</p><pre class=" language-ASM"><code class="language-ASM">;5.7 求出首地址为 DATA 的 100D 字数组中的最小偶数，并存放在 AX 中S1 SEGMENT    DATA DW 100D DUP(?)S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV BX,0    MOV CX,100    L0:    MOV AX,DATA[BX]    TEST AX,1    ADD BX,2    LOOPNZ L0    ;ZF=0和CF>0，继续循环    JNZ EXIT    ;循环结束且没有偶数    JCXZ EXIT    ;循环结束且最后一个是偶数，在BX    JZ    L1        ;循环未结束，找到偶数 进行比较L1:    MOV DX,DATA[BX]    TEST DX,1    ADD BX,2    JNZ    L0    CMP DX,AX        JGE    L2        ;继续向下找更小的偶数    MOV AX,DX    ;更新最小偶数值    LOOP L0L2:    LOOP L1EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-8-把-AX-中存放的-16-位二进制数-K-看作是-8-个二进制的“四分之一字节”"><a href="#5-8-把-AX-中存放的-16-位二进制数-K-看作是-8-个二进制的“四分之一字节”" class="headerlink" title="5.8 把 AX 中存放的 16 位二进制数 K 看作是 8 个二进制的“四分之一字节”"></a>5.8 把 AX 中存放的 16 位二进制数 K 看作是 8 个二进制的“四分之一字节”</h3><h3 id="数一下值为-3-即-11B-的四分之一的字节数，并将该数在终端上显示出来。"><a href="#数一下值为-3-即-11B-的四分之一的字节数，并将该数在终端上显示出来。" class="headerlink" title="数一下值为 3(即 11B)的四分之一的字节数，并将该数在终端上显示出来。"></a>数一下值为 3(即 11B)的四分之一的字节数，并将该数在终端上显示出来。</h3><pre class=" language-ASM"><code class="language-ASM">;5.8 把 AX 中存放的 16 位二进制数 K 看作是 8 个二进制的“四分之一字节”。;数一下值为 3(即 11B)的四分之一字节数，并将该数在终端上显示出来。S1 SEGMENT    K DW 6C3BHS1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV AX,K    MOV BP,8        ;循环次数    MOV CL,2        ;循环位数    XOR DX,DX        ;11B的个数    L0:    CMP BP,0    JE    EXIT    DEC BP        ROL AX,CL    MOV BX,AX    AND BX,3    CMP BX,3        JE    L1    JNE L0    L1:    INC DX    JMP L0    EXIT:    ADD DL,30H    MOV AH,2    INT 21H        MOV AH,4CH    INT 21H    MAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-9输入一个四位的-16-进制数，并在终端上显示等值的二进制数"><a href="#5-9输入一个四位的-16-进制数，并在终端上显示等值的二进制数" class="headerlink" title="5.9输入一个四位的 16 进制数，并在终端上显示等值的二进制数"></a>5.9输入一个四位的 16 进制数，并在终端上显示等值的二进制数</h3><pre class=" language-ASM"><code class="language-ASM">;5.9 输入一个四位的 16 进制数，并在终端上显示等值的二进制数。S1 SEGMENTS1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        ;输入    MOV BX,0    MOV CX,4L0:    PUSH CX    MOV CL,4    ROL BX,CL    MOV AH,1    INT 21H        ;NUMBER    CMP AL,30H    JB    L0    CMP AL,39H    JA    L1    SUB AL,30H    JMP L3    L1:    ;APHAL    CMP AL,41H    JB    L0    CMP AL,46H    JA    L2    SUB AL,37H    JMP L3    L2:    ;SMALL A    CMP AL,61H    JB    L0    CMP AL,66H    JA    L0    SUB AL,57H    JMP L3L3:    ADD BL,AL    POP CX    LOOP L0        MOV DL,0DH    MOV AH,2    INT 21H    MOV DL,0AH    MOV AH,2    INT 21H        MOV CX,16L4:    MOV DL,30H    ROL BX,1    ADC DL,0    MOV AH,2    INT 21H    LOOP L4        MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-10设有一段英文，其字符变量名为-ENG，并以-字符结束。试编写一程序，查对单词-SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。"><a href="#5-10设有一段英文，其字符变量名为-ENG，并以-字符结束。试编写一程序，查对单词-SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。" class="headerlink" title="5.10设有一段英文，其字符变量名为 ENG，并以$字符结束。试编写一程序，查对单词 SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。"></a>5.10设有一段英文，其字符变量名为 ENG，并以$字符结束。试编写一程序，查对单词 SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。</h3><pre class=" language-ASM"><code class="language-ASM">;5.10 一段英文 名ENG，以$结束,计算SUN在该文中出现的字数，格式SUNXXXX显示出次数S1 SEGMENT    ENG DB 'SUNSSUN;;SUN S,,,SUN$'    PUT DB 'SUN'    COUNT DB '0000',0DH,0AH,'$'    SUN DB 'SUN'S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV ES,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        XOR AX,AX    MOV DX,PUT-ENG-2    CALL CMPSTR    CALL CHANGE    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPCMPSTR PROC NEARL1:    MOV DI,BX    LEA SI,SUN        MOV CX,3    REPE CMPSB    JNZ L2    INC AX    ADD BX,2 ;匹配成功    SUB DX,2L2:    INC BX ;匹配下一个    DEC DX    CMP DX,0    JG L1CMPSTR ENDPCHANGE PROC NEARL3:    MOV CH,4     MOV CL,4    LEA BX,COUNT L4:     ROL AX,CL    MOV DX,AX    AND DL,0FH ;取一位16进制数    ADD DL,30H    CMP DL,39H    JLE L5    ADD DL,07HL5:     MOV [BX],DL    INC BX    DEC CH    JNZ L4         LEA DX,PUT     MOV AH,09H    INT 21HCHANGE ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-11从键盘输入一系列以-为结束符的字符串，对其中非数字字符计数，并显示计数结果。"><a href="#5-11从键盘输入一系列以-为结束符的字符串，对其中非数字字符计数，并显示计数结果。" class="headerlink" title="5.11从键盘输入一系列以$为结束符的字符串，对其中非数字字符计数，并显示计数结果。"></a>5.11从键盘输入一系列以$为结束符的字符串，对其中<u>非数字字符</u>计数，并显示计数结果。</h3><pre class=" language-ASM"><code class="language-ASM">;从键盘输入一系列以$为结束符的字符串，;对其中的非数字字符计数，并显示出计数结果。S1 SEGMENT    STRING DB 100 DUP(?)    CNT DW 0    DISPLAY DB 0DH,0AH,'THE COUNT:$'S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP       LEA BX,STRINGL1:    MOV AH,1        ;输入    INT 21H    MOV [BX],AL    INC BX    CMP AL,'$'        ;结束?    JE    L3                CMP AL,30H        ;0-9    JB    L2    CMP AL,39H    JA    L2    JMP L1    L2:    INC CNT    JMP L1    L3:    ;转成十进制    MOV AX,CNT    MOV BL,10    DIV BL    MOV BX,AX        LEA DX,DISPLAY    MOV AH,9    INT 21H        ;BX放到DX    MOV DL,30H    ADD DL,BL    MOV AH,2    INT 21H        MOV DL,30H    ADD DL,BH    MOV AH,2    INT 21H        MOV DL,0DH    MOV AH,2    INT 21H    MOV DL,0AH    MOV AH,2    INT 21H    EXIT:       MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-12-首地址为-MEM-的-100D-字数组，删除数组中所有为-0-的项，并将后续项向前压缩，最后将数组的剩余部分补上-0"><a href="#5-12-首地址为-MEM-的-100D-字数组，删除数组中所有为-0-的项，并将后续项向前压缩，最后将数组的剩余部分补上-0" class="headerlink" title="5.12 首地址为 MEM 的 100D 字数组，删除数组中所有为 0 的项，并将后续项向前压缩，最后将数组的剩余部分补上 0"></a>5.12 首地址为 MEM 的 100D 字数组，删除数组中所有为 0 的项，并将后续项向前压缩，最后将数组的剩余部分补上 0</h3><pre class=" language-ASM"><code class="language-ASM">;5.12 首地址为 MEM 的 100D 字数组，删除数组中所有为 0 的项，;并将后续项向前压缩，最后将数组的剩余部分补上 0。S1 SEGMENT    MEM DW 1,0,0,0,0,0,0,0,0,0        DW 2,1,0,3,4,5,6,7,8,9        DW 3,0,0,0,0,0,0,0,0,0        DW 4,1,2,0,4,5,6,7,8,9        DW 5,0,0,0,0,0,0,0,0,0        DW 6,1,2,3,4,5,0,7,8,9        DW 7,0,0,0,0,0,0,0,0,0        DW 8,1,2,3,4,5,6,7,0,9        DW 9,0,0,0,0,0,0,0,0,0        DW 0,1,2,3,4,5,6,7,8,0    CNT DW 0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV CX,100    MOV SI,0L0:    CMP CX,0    JE    L3        MOV AX,MEM[SI]    MOV DI,SI    ADD SI,2    DEC CX    CMP AX,0    JNE    L0        ;把后面的前移L1:    INC CNT            ;记录数组中0的个数    MOV DX,MEM[SI]    MOV MEM[DI],DX    ;DX是中间量    JMP L0        ;剩余部分补零    MOV CX,CNTL3:    MOV SI,198    MOV MEM[SI],0    SUB SI,2    LOOP L3    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-13在-STRING-到-STRING-99-单元中存放着一个字符串"><a href="#5-13在-STRING-到-STRING-99-单元中存放着一个字符串" class="headerlink" title="5.13在 STRING 到 STRING+99 单元中存放着一个字符串"></a>5.13在 STRING 到 STRING+99 单元中存放着一个字符串</h3><p>测试该字符串中是否存在数字，如有则把 CL 的第 5 位置 1，否则将该位置 0。</p><pre class=" language-ASM"><code class="language-ASM">;在 STRING 到 STRING+99 单元中存放着一个字符串;测试该字符串中是否存在数字，如有则把 CL 的第 5 位置 1，否则将该位置 0。S1 SEGMENT    STRING DB 'HELLOABCDE1',90 DUP('A') S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP       MOV CX,100    LEA BX,STRING L0:    MOV AL,[BX]    INC BX    CMP AL,30H    JB    L1    CMP AL,39H    JNA    L2L1:    LOOP L0        ;存在数字L2:    MOV CL,00010000b    JMP EXIT  EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-14"><a href="#5-14" class="headerlink" title="5.14"></a>5.14</h3><pre class=" language-ASM"><code class="language-ASM">;5.14 在首地址为 TABLE 的数组中按递增次序存放着 100H 个 16 位补码数;把出现次数最多的数及其出现次数分别存放于 AX 和 CX 中S1 SEGMENT    TABEL    DW    6 DUP(-1),10 DUP(1),25 DUP(2),15 DUP(3),200 DUP(4)    TEMP    DW    ?S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV CX,128    MOV SI,0    ;第二组的个数    MOV DI,0    ;第一组的个数    MOV DX,0    ;出现次数最大的值    LEA BX,TABEL    MOV DX,[BX]    ;一段一段记录个数，相等增加个数，大于则记录下一组，比较存储两组个数，再进行下一轮L1:    CMP CX,0    JE    EXIT    DEC CX        ;后边组的个数是DI   后指针    MOV AX,[BX]    ADD BX,2    INC DI    CMP    AX,[BX]    JNE L2        CMP CX,0    JNE    L1    L2:    CMP DI,SI    JB    L3        ;不用变动    ;后边组的次数更多，需要更新    MOV DX,AX    ;DX保存数值较大值    MOV SI,DI    ;SI保存次数较大值L3:    XOR    DI,DI    JMP L1            EXIT:    MOV CX,SI        MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-15-数据段中已定义了一个有-n-个字数据的数组-M-求出-M-中绝对值最大的数，放在数据段的-M-2n-单元中-最后一个单元-并将该数的偏移地址存放在-M-2-n-1-单元中"><a href="#5-15-数据段中已定义了一个有-n-个字数据的数组-M-求出-M-中绝对值最大的数，放在数据段的-M-2n-单元中-最后一个单元-并将该数的偏移地址存放在-M-2-n-1-单元中" class="headerlink" title="5.15 数据段中已定义了一个有 n 个字数据的数组 M,求出 M 中绝对值最大的数，放在数据段的 M+2n 单元中(最后一个单元),并将该数的偏移地址存放在 M+2(n+1)单元中"></a>5.15 数据段中已定义了一个有 n 个<u>字</u>数据的数组 M,求出 M 中绝对值最大的数，放在数据段的 M+2n 单元中(最后一个单元),并将该数的偏移地址存放在 M+2(n+1)单元中</h3><pre class=" language-ASM"><code class="language-ASM">;5.15 数据段中已定义了一个有 n 个字数据的数组 M，;求出 M 中绝对值最大的数，放在数据段的 M+2n 单元中;并将该数的偏移地址存放在 M+2(n+1)单元中S1 SEGMENT    M DW 10 DUP(5),10 DUP(2),5 DUP(-10)    CNT    DW    ($-M)/2    MAX    DW    ?    ADDRESS DW ?S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        ;第一次    MOV SI,0    MOV AX,M[SI]    ADD SI,2    CMP AX,0    JGE    L0    NEG AXL0:        MOV MAX,AX    MOV BX,SI        ;N-1次循环比较    MOV CX,CNT    DEC CX L1:    CMP CX,0    JE    L3    MOV AX,M[SI]    ADD SI,2    DEC CX    CMP AX,0    JGE    L2    NEG AX    L2:    CMP MAX,AX    JAE L1    ;出现绝对值更大的数，需更新    MOV MAX,AX    MOV BX,SI    JMP L1        ;存放数据L3:    ADD SI,2    MOV DX,M[BX]    MOV M[SI],DX    ADD SI,2    MOV M[SI],BX    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-16在首地址为-DATA-的字数组中存放着-100H-个-16-位补码数"><a href="#5-16在首地址为-DATA-的字数组中存放着-100H-个-16-位补码数" class="headerlink" title="5.16在首地址为 DATA 的字数组中存放着 100H 个 16 位补码数"></a>5.16在首地址为 DATA 的字数组中存放着 100H 个 16 位补码数</h3><p>求出它们的平均值放在 AX 寄存器中,并求出数组中有多少个数小于此平均值，将结果放在 BX 寄存 器中。 </p><pre class=" language-ASM"><code class="language-ASM">;5.16 在首地址为 DATA 的字数组中存放着 100H 个 16 位补码数;求出它们的平均值放在 AX 寄存器中；;并求出数组中有多少个数小于此平均值，将结果放在 BX 寄存 器中。 S1 SEGMENT    DATA DW    3 DUP(-1),4 DUP(1),25 DUP(2),15 DUP(3),200 DUP(4)    AVER DW ?    CNT    DW    0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV CX,128    MOV AX,0    MOV SI,0L0:    MOV DX,DATA[SI]    ADD SI,2    ADD AX,DX    ;AX作SUM    LOOP L0        MOV BP,100H    DIV BP    MOV AH,0    MOV AVER,AX    ;遍历比较    MOV SI,0    MOV CX,128L1:     MOV DX,DATA[SI]    ADD SI,2    CMP DX,AVER    JAE L2    INC CNTL2:    LOOP L1        MOV BX,CNTEXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-17把-AX-中的-16-进制数转换为-ASCII-码-并将对应的-ASCII-码依次存放到-MEM-数组中的四个字节中"><a href="#5-17把-AX-中的-16-进制数转换为-ASCII-码-并将对应的-ASCII-码依次存放到-MEM-数组中的四个字节中" class="headerlink" title="5.17把 AX 中的 16 进制数转换为 ASCII 码,并将对应的 ASCII 码依次存放到 MEM 数组中的四个字节中"></a>5.17把 AX 中的 16 进制数转换为 ASCII 码,并将对应的 ASCII 码依次存放到 MEM 数组中的四个字节中</h3><p>例如，当(AX)=2A49H 时，MEM 中的 4 个字节为39H，34H，41H，32H</p><pre class=" language-asm"><code class="language-asm">;5.17 试编制一个程序把 AX 中的 16 进制数转换为 ASCII 码;并将对应的 ASCII 码依次存放到 MEM 数组中的四个字节中;例如，当(AX)=2A49H 时，MEM 中的 4 个字节为39H，34H，41H，32HS1 SEGMENT    MEM DB 4 DUP(?)S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV AX,2A49H    MOV CX,4    MOV SI,3L0:    PUSH CX    MOV CL,4    ROL AX,CL    MOV DX,AX    AND DX,0FH    ADD DX,30H    CMP DX,3AH    JB    L1    ADD DX,7        ;存放数据    L1:    MOV MEM[SI],DL    DEC SI    POP CX    LOOP L0        EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-18把-0-100D-之间的-30-个数存入以-GRADE-为首地址的-30-字数组中"><a href="#5-18把-0-100D-之间的-30-个数存入以-GRADE-为首地址的-30-字数组中" class="headerlink" title="5.18把 0~100D 之间的 30 个数存入以 GRADE 为首地址的 30 字数组中"></a>5.18把 0~100D 之间的 30 个数存入以 GRADE 为首地址的 30 字数组中</h3><p>GRADE+i 表示学号为 i+1 的学生的成绩<br>数组 RANK 为 30 个学生的名次表<br>RANK+i 的内容是学号为 i+1 的学生的名次<br>根据 GRADE 中的学生成绩，将学生名次填入 RANK数组中<br>(提示：一个学生的名次等于成绩高于这个学生的人数加 1)</p><pre class=" language-asm"><code class="language-asm">;5.18 把 0~100D 之间的 30 个数存入以 GRADE 为首地址的 30 字数组中;GRADE+i 表示学号为 i+1 的学生的成绩;数组 RANK 为 30 个学生的名次表;RANK+i 的内容是学号为 i+1 的学生的名次;根据 GRADE 中的学生成绩，将学生名次填入 RANK数组中;(提示：一个学生的名次等于成绩高于这个学生的人数加 1。S1 SEGMENT    GRADE DW 13 DUP(90),4 DUP(80),5 DUP(70),2 DUP(60),0064H,6 DUP(95)    NUM DW 0    RANK DW 30 DUP(?)S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV SI,0    MOV DI,0    MOV CX,30L0:    MOV AX,GRADE[SI]    ADD SI,2    MOV DI,0    MOV NUM,0    L1:    CMP DI,30    JE    L3    MOV BX,GRADE[DI]    ADD DI,2    CMP AX,BX    JA    L2    JMP L1    L2:    INC NUM    JMP L1    L3:    MOV DX,NUM    MOV RANK[SI],DX    LOOP L0    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-19-已知数组-A-包含-15-个互不相等的整数，数组-B-包含-20-个互不相等的整数"><a href="#5-19-已知数组-A-包含-15-个互不相等的整数，数组-B-包含-20-个互不相等的整数" class="headerlink" title="5.19 已知数组 A 包含 15 个互不相等的整数，数组 B 包含 20 个互不相等的整数"></a>5.19 已知数组 A 包含 15 个互不相等的整数，数组 B 包含 20 个互不相等的整数</h3><h3 id="把既在-A-中又在-B-中出现的整数存放于数组-C-中"><a href="#把既在-A-中又在-B-中出现的整数存放于数组-C-中" class="headerlink" title="把既在 A 中又在 B 中出现的整数存放于数组 C 中"></a>把既在 A 中又在 B 中出现的整数存放于数组 C 中</h3><pre class=" language-asm"><code class="language-asm">;5.19 已知数组 A 包含 15 个互不相等的整数，数组 B 包含 20 个互不相等的整数;把既在 A 中又在 B 中出现的整数存放于数组 C 中S1 SEGMENT    ARRYA    DB    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14    ARRYB    DB    5,6,7,8,9,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29    ARRYC    DB    15 DUP(?)S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV SI,0    MOV BX,0    MOV CX,15    ;外循环L0:    PUSH CX    MOV CX,20        MOV AL,ARRYA[SI]    INC SI        ;内循环    MOV DI,0L1:    CMP ARRYB[DI],AL    INC DI    JE L2            LOOP L1        ;接着比较    L2:    MOV ARRYC[BX],AL    INC BX        POP CX        LOOP L0        EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-20-设在-A、B-和-C-单元中分别存放着三个数。"><a href="#5-20-设在-A、B-和-C-单元中分别存放着三个数。" class="headerlink" title="5.20 设在 A、B 和 C 单元中分别存放着三个数。"></a>5.20 设在 A、B 和 C 单元中分别存放着三个数。</h3><h3 id="若三个数都不是-0，则求出三数之和存放在D-单元中"><a href="#若三个数都不是-0，则求出三数之和存放在D-单元中" class="headerlink" title="若三个数都不是 0，则求出三数之和存放在D 单元中"></a>若三个数都不是 0，则求出三数之和存放在D 单元中</h3><h3 id="若其中有一个数为-0，则把其它两单元也清-0"><a href="#若其中有一个数为-0，则把其它两单元也清-0" class="headerlink" title="若其中有一个数为 0，则把其它两单元也清 0"></a>若其中有一个数为 0，则把其它两单元也清 0</h3><pre class=" language-asm"><code class="language-asm">;5.20 设在 A、B 和 C 单元中分别存放着三个数。;若三个数都不是 0，则求出三数之和存放在D 单元中;若其中有一个数为 0，则把其它两单元也清 0S1 SEGMENT    NUMA    DW    10    NUMB    DW    0    NUMC    DW    0    NUMD    DW    0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    XOR DX,DX    MOV AX,NUMA    CMP AX,0    JE  L1    ADD DX,AX        MOV AX,NUMB    CMP AX,0    JE  L1    ADD DX,AX        MOV AX,NUMC    CMP AX,0    JE  L1    ADD DX,AX    JMP L2        ;清零L1:    MOV BX,0    LEA SI,NUMA    MOV [SI],BX    LEA SI,NUMB    MOV [SI],BX    LEA SI,NUMC    MOV [SI],BX    JMP EXIT    L2:    LEA DI,NUMD    MOV DX,[DI]EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-21比较数组-ARRAY-中的三个-16-位补码数，并根据比较结果在终端上显示如下信息："><a href="#5-21比较数组-ARRAY-中的三个-16-位补码数，并根据比较结果在终端上显示如下信息：" class="headerlink" title="5.21比较数组 ARRAY 中的三个 16 位补码数，并根据比较结果在终端上显示如下信息："></a>5.21比较数组 ARRAY 中的三个 16 位补码数，并根据比较结果在终端上显示如下信息：</h3><h3 id="1-如果三个数都不相等则显示-0；"><a href="#1-如果三个数都不相等则显示-0；" class="headerlink" title="(1) 如果三个数都不相等则显示 0；"></a>(1) 如果三个数都不相等则显示 0；</h3><h3 id="2-如果三个数有二个数相等则显示-1；"><a href="#2-如果三个数有二个数相等则显示-1；" class="headerlink" title="(2) 如果三个数有二个数相等则显示 1；"></a>(2) 如果三个数有二个数相等则显示 1；</h3><h3 id="3-如果三个数都相等则显示-2"><a href="#3-如果三个数都相等则显示-2" class="headerlink" title="(3) 如果三个数都相等则显示 2"></a>(3) 如果三个数都相等则显示 2</h3><pre class=" language-ASM"><code class="language-ASM">;5.21比较数组 ARRAY 中的三个 16 位补码数，并根据比较结果在终端上显示如下信息：;(1) 如果三个数都不相等则显示 0；;(2) 如果三个数有二个数相等则显示 1；;(3) 如果三个数都相等则显示 2S1 SEGMENT    ARRAY    DW    1,2,1S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    LEA SI,ARRAY    MOV AX,[SI]    ADD SI,2    MOV BX,[SI]    ADD SI,2    MOV DX,[SI]    CMP AX,BX    JE  L1    JNE L2        ;A=BL1:    CMP BX,DX    JE    L3    JNE L4        ;A≠BL2:    CMP BX,DX    JE    L4    CMP AX,DX    JE    L4    JNE L5        ;ALL OKL3:    MOV DL,32H    MOV AH,2    INT 21H    JMP EXIT        ;JUST ONEL4:    MOV DL,31H    MOV AH,2    INT 21H    JMP EXIT        ;ALL NOTL5:    MOV DL,30H    MOV AH,2    INT 21H    JMP EXITEXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-22-从键盘输入一系列字符-以回车符结束-，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果-OK"><a href="#5-22-从键盘输入一系列字符-以回车符结束-，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果-OK" class="headerlink" title="5.22 从键盘输入一系列字符(以回车符结束)，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果 OK"></a>5.22 从键盘输入一系列字符(以回车符结束)，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果 OK</h3><pre class=" language-ASM"><code class="language-ASM">;从键盘输入一系列字符(以回车符结束)，并按字母、数字、及其它字符分类计数，;最后显示出这三类的计数结果S1 SEGMENT    BUFF    DB 250,?,250 DUP(?)    CNTA    DW    0    CNTN    DW    0    CNTO    DW    0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    LEA DX,BUFF    MOV    AH,0AH    INT 21H        MOV    SI,1    XOR CH,CH    MOV CL,BUFF[SI]L0:    INC SI    MOV AL,BUFF[SI]    CMP AL,30H    JB    L3    CMP AL,3AH    JB    L2    CMP AL,41H    JB    L3    CMP AL,5AH    JB    L1    CMP AL,61H    JB    L3    CMP AL,7AH    JB    L1L1:    INC CNTA    MOV BX,CNTA    LOOP L0L2:    INC CNTN    MOV DX,CNTN    LOOP L0L3:    INC CNTO    MOV DI,CNTO    LOOP L0        MOV DX,0DH    MOV AH,2    INT 21H    MOV DX,0AH    MOV AH,2    INT 21H    MOV DX,CNTA    MOV AH,2    ADD DX,30H    INT 21H        MOV DX,CNTN    ADD DX,30H    MOV AH,2    INT 21H    MOV DX,0DH    MOV AH,2    INT 21H    MOV DX,0AH    MOV AH,2    INT 21H        MOV DX,CNTO    ADD DX,30H    MOV AH,2    INT 21H    MOV DX,0DH    MOV AH,2    INT 21H    MOV DX,0AH    MOV AH,2    INT 21HEXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-23-已定义了两个整数变量-A-和-B，试编写程序完成下列功能："><a href="#5-23-已定义了两个整数变量-A-和-B，试编写程序完成下列功能：" class="headerlink" title="5.23 已定义了两个整数变量 A 和 B，试编写程序完成下列功能："></a>5.23 已定义了两个整数变量 A 和 B，试编写程序完成下列功能：</h3><p>(1) 若两个数中有一个是奇数，则将奇数存入 A 中，偶数存入 B 中；</p><p>(2) 若两个数中均为奇数，则将两数加 1 后存回原变量；</p><p>(3) 若两个数中均为偶数，则两个变量均不改变。</p><pre class=" language-ASM"><code class="language-ASM">;5.23 已定义了两个整数变量 A 和 B;(1) 若两个数中有一个是奇数，则将奇数存入 A 中，偶数存入 B 中；;(2) 若两个数中均为奇数，则将两数加 1 后存回原变量；;(3) 若两个数中均为偶数，则两个变量均不改变。S1 SEGMENT    NUMA    DW    2A32H    NUMB    DW    2A31HS1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOPL0:    MOV AX,NUMA    TEST AX,1    JE    L2        ;奇数L1:    MOV BX,NUMB    TEST BX,1    JNE    L4    JMP EXIT            ;偶数L2:        MOV BX,NUMB    TEST BX,1    JNE    L3    JMP EXIT        ;A奇B偶L3:    XCHG AX,BX    JMP EXIT    ;都是奇数，都+1L4:    INC AX    LEA SI,NUMA    MOV [SI],AX    INC BX    LEA SI,NUMB    MOV [SI],BX    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre>]]></content>
      
      
      <categories>
          
          <category> ASM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/02/10/MySQL%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/02/10/MySQL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL笔记"><a href="#MySQL笔记" class="headerlink" title="MySQL笔记"></a>MySQL笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><pre class=" language-shell"><code class="language-shell"># 登录MySQL$ mysql -u root -p12345612# 退出MySQL数据库服务器exit;</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre class=" language-mysql"><code class="language-mysql">-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet (    name VARCHAR(20),    owner VARCHAR(20),    species VARCHAR(20),    sex CHAR(1),    birth DATE,    death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 插入数据INSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL);-- 修改数据UPDATE pet SET name = 'squirrel' where owner = 'Diane';-- 删除数据DELETE FROM pet where name = 'squirrel';-- 删除表DROP TABLE myorder;</code></pre><h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><pre class=" language-mysql"><code class="language-mysql">-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20));-- 联合主键-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。CREATE TABLE user (    id INT,    name VARCHAR(20),    password VARCHAR(20),    PRIMARY KEY(id, name));-- 自增约束-- 自增约束的主键由系统自动递增分配。CREATE TABLE user (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20));-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY;</code></pre><h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><pre class=" language-mysql"><code class="language-mysql">-- 建表时创建唯一主键CREATE TABLE user (    id INT,    name VARCHAR(20),    UNIQUE(name));-- 添加唯一主键-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一主键ALTER TABLE user DROP INDEX name;</code></pre><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><pre class=" language-mysql"><code class="language-mysql">-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user (    id INT,    name VARCHAR(20) NOT NULL);-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20);</code></pre><h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><pre class=" language-mysql"><code class="language-mysql">-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user2 (    id INT,    name VARCHAR(20),    age INT DEFAULT 10);-- 移除非空约束ALTER TABLE user MODIFY age INT;</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><pre class=" language-mysql"><code class="language-mysql">-- 班级CREATE TABLE classes (    id INT PRIMARY KEY,    name VARCHAR(20));-- 学生表CREATE TABLE students (    id INT PRIMARY KEY,    name VARCHAR(20),    -- 这里的 class_id 要和 classes 中的 id 字段相关联    class_id INT,    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值    FOREIGN KEY(class_id) REFERENCES classes(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；-- 2. 主表中的记录被副表引用时，主表不可以被删除。</code></pre><h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p><p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p><pre class=" language-mysql"><code class="language-mysql">-- 订单表CREATE TABLE myorder (    product_id INT,    customer_id INT,    product_name VARCHAR(20),    customer_name VARCHAR(20),    PRIMARY KEY (product_id, customer_id));</code></pre><p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p><p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT);CREATE TABLE product (    id INT PRIMARY KEY,    name VARCHAR(20));CREATE TABLE customer (    id INT PRIMARY KEY,    name VARCHAR(20));</code></pre><p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT,    customer_phone VARCHAR(15));</code></pre><p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT);CREATE TABLE customer (    id INT PRIMARY KEY,    name VARCHAR(20),    phone VARCHAR(15));</code></pre><p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p><h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><pre class=" language-mysql"><code class="language-mysql">-- 创建数据库CREATE DATABASE select_test;-- 切换数据库USE select_test;-- 创建学生表CREATE TABLE student (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    sex VARCHAR(10) NOT NULL,    birthday DATE, -- 生日    class VARCHAR(20) -- 所在班级);-- 创建教师表CREATE TABLE teacher (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    sex VARCHAR(10) NOT NULL,    birthday DATE,    profession VARCHAR(20) NOT NULL, -- 职称    department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表CREATE TABLE course (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    t_no VARCHAR(20) NOT NULL, -- 教师编号    -- 表示该 tno 来自于 teacher 表中的 no 字段值    FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表CREATE TABLE score (    s_no VARCHAR(20) NOT NULL, -- 学生编号    c_no VARCHAR(20) NOT NULL, -- 课程号    degree DECIMAL,    -- 成绩    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值    FOREIGN KEY(s_no) REFERENCES student(no),        FOREIGN KEY(c_no) REFERENCES course(no),    -- 设置 s_no, c_no 为联合主键    PRIMARY KEY(s_no, c_no));-- 查看所有表SHOW TABLES;-- 添加学生表数据INSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033');INSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031');INSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033');INSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033');INSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031');INSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031');INSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033');INSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031');INSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031');-- 添加教师表数据INSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系');INSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系');INSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系');INSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系');-- 添加课程表数据INSERT INTO course VALUES('3-105', '计算机导论', '825');INSERT INTO course VALUES('3-245', '操作系统', '804');INSERT INTO course VALUES('6-166', '数字电路', '856');INSERT INTO course VALUES('9-888', '高等数学', '831');-- 添加添加成绩表数据INSERT INTO score VALUES('103', '3-105', '92');INSERT INTO score VALUES('103', '3-245', '86');INSERT INTO score VALUES('103', '6-166', '85');INSERT INTO score VALUES('105', '3-105', '88');INSERT INTO score VALUES('105', '3-245', '75');INSERT INTO score VALUES('105', '6-166', '79');INSERT INTO score VALUES('109', '3-105', '76');INSERT INTO score VALUES('109', '3-245', '68');INSERT INTO score VALUES('109', '6-166', '81');-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher;</code></pre><h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><pre class=" language-mysql"><code class="language-mysql">-- 查询 student 表的所有行SELECT * FROM student;-- 查询 student 表中的 name、sex 和 class 字段的所有行SELECT name, sex, class FROM student;-- 查询 teacher 表中不重复的 department 列-- department: 去重查询SELECT DISTINCT department FROM teacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 "并且"SELECT * FROM score WHERE degree BETWEEN 60 AND 80;SELECT * FROM score WHERE degree > 60 AND degree < 80;-- 查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值SELECT * FROM score WHERE degree IN (85, 86, 88);-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行-- or: 表示或者关系SELECT * FROM student WHERE class = '95031' or sex = '女';-- 以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高SELECT * FROM student ORDER BY class DESC;SELECT * FROM student ORDER BY class ASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行SELECT * FROM score ORDER BY c_no ASC, degree DESC;-- 查询 "95031" 班的学生人数-- COUNT: 统计SELECT COUNT(*) FROM student WHERE class = '95031';-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分SELECT s_no, c_no FROM score WHERE degree = (SELECT MAX(degree) FROM score);--  排序查询-- LIMIT r, n: 表示从第r行开始，查询n条数据SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;</code></pre><h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- AVG: 平均值SELECT AVG(degree) FROM score WHERE c_no = '3-105';SELECT AVG(degree) FROM score WHERE c_no = '3-245';SELECT AVG(degree) FROM score WHERE c_no = '6-166';-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</code></pre><h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score;-- c_no 课程编号+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p><pre class=" language-mysql"><code class="language-mysql">-- 首先把 c_no, AVG(degree) 通过分组查询出来SELECT c_no, AVG(degree) FROM score GROUP BY c_no+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     85.3333 || 3-245 |     76.3333 || 6-166 |     81.6667 |+-------+-------------+-- 再查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) >= 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，"%" 是一个通配符，匹配 "3" 后面的任意字符。AND c_no LIKE '3%';-- 把前面的SQL语句拼接起来，-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_noHAVING COUNT(c_no) >= 2 AND c_no LIKE '3%';+-------+-------------+----------+| c_no  | AVG(degree) | COUNT(*) |+-------+-------------+----------+| 3-105 |     85.3333 |        3 || 3-245 |     76.3333 |        3 |+-------+-------------+----------+</code></pre><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT no, name FROM student;+-----+-----------+| no  | name      |+-----+-----------+| 101 | 曾华      || 102 | 匡明      || 103 | 王丽      || 104 | 李军      || 105 | 王芳      || 106 | 陆军      || 107 | 王尼玛    || 108 | 张全蛋    || 109 | 赵铁柱    |+-----+-----------+SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p><pre class=" language-mysql"><code class="language-mysql">-- FROM...: 表示从 student, score 表中查询-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name      | c_no  | degree |+-----------+-------+--------+| 王丽      | 3-105 |     92 || 王丽      | 3-245 |     86 || 王丽      | 6-166 |     85 || 王芳      | 3-105 |     88 || 王芳      | 3-245 |     75 || 王芳      | 6-166 |     79 || 赵铁柱    | 3-105 |     76 || 赵铁柱    | 3-245 |     68 || 赵铁柱    | 6-166 |     81 |+-----------+-------+--------+</code></pre><h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p><p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p><pre class=" language-mysql"><code class="language-mysql">SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>然后查询 <code>course</code> 表：</p><pre class=" language-mysql"><code class="language-mysql">+-------+-----------------+| no    | name            |+-------+-----------------+| 3-105 | 计算机导论      || 3-245 | 操作系统        || 6-166 | 数字电路        || 9-888 | 高等数学        |+-------+-----------------+</code></pre><p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p><pre class=" language-mysql"><code class="language-mysql">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。-- as 表示取一个该字段的别名。SELECT s_no, name as c_name, degree FROM score, courseWHERE score.c_no = course.no;+------+-----------------+--------+| s_no | c_name          | degree |+------+-----------------+--------+| 103  | 计算机导论      |     92 || 105  | 计算机导论      |     88 || 109  | 计算机导论      |     76 || 103  | 操作系统        |     86 || 105  | 操作系统        |     75 || 109  | 操作系统        |     68 || 103  | 数字电路        |     85 || 105  | 数字电路        |     79 || 109  | 数字电路        |     81 |+------+-----------------+--------+</code></pre><h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p><p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p><p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p><pre class=" language-mysql"><code class="language-mysql">SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name      | c_no  | degree |+-----------+-------+--------+| 王丽      | 3-105 |     92 || 王丽      | 3-245 |     86 || 王丽      | 6-166 |     85 || 王芳      | 3-105 |     88 || 王芳      | 3-245 |     75 || 王芳      | 6-166 |     79 || 赵铁柱    | 3-105 |     76 || 赵铁柱    | 3-245 |     68 || 赵铁柱    | 6-166 |     81 |+-----------+-------+--------+</code></pre><p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p><pre class=" language-mysql"><code class="language-mysql">-- 课程表SELECT no, name FROM course;+-------+-----------------+| no    | name            |+-------+-----------------+| 3-105 | 计算机导论      || 3-245 | 操作系统        || 6-166 | 数字电路        || 9-888 | 高等数学        |+-------+-----------------+-- 由于字段名存在重复，使用 "表名.字段名 as 别名" 代替。SELECT student.name as s_name, course.name as c_name, degree FROM student, score, courseWHERE student.NO = score.s_noAND score.c_no = course.no;</code></pre><h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p><p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p><pre class=" language-mysql"><code class="language-mysql">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询SELECT s_no, c_no, degree FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p><pre class=" language-mysql"><code class="language-mysql">SELECT c_no, AVG(degree) FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031')GROUP BY c_no;+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     82.0000 || 3-245 |     71.5000 || 6-166 |     80.0000 |+-------+-------------+</code></pre><h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p><p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = '3-105'AND degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');</code></pre><h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。SELECT * FROM scoreWHERE degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');</code></pre><h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- YEAR(..): 取出日期中的年份SELECT no, name, birthday FROM studentWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));</code></pre><h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p><p>首先找到教师编号：</p><pre class=" language-mysql"><code class="language-mysql">SELECT NO FROM teacher WHERE NAME = '张旭'</code></pre><p>通过 <code>sourse</code> 表找到该教师课程号：</p><pre class=" language-mysql"><code class="language-mysql">SELECT NO FROM course WHERE t_no = ( SELECT NO FROM teacher WHERE NAME = '张旭' );</code></pre><p>通过筛选出的课程号查询成绩表：</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = (    SELECT no FROM course WHERE t_no = (         SELECT no FROM teacher WHERE NAME = '张旭'     ));</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p><p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p><pre class=" language-mysql"><code class="language-mysql">-- 查询 teacher 表SELECT no, name FROM teacher;+-----+--------+| no  | name   |+-----+--------+| 804 | 李诚   || 825 | 王萍   || 831 | 刘冰   || 856 | 张旭   |+-----+--------+SELECT name FROM teacher WHERE no IN (    -- 在这里找到对应的条件);</code></pre><p>查看和教师编号有有关的表的信息：</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM course;-- t_no: 教师编号+-------+-----------------+------+| no    | name            | t_no |+-------+-----------------+------+| 3-105 | 计算机导论      | 825  || 3-245 | 操作系统        | 804  || 6-166 | 数字电路        | 856  || 9-888 | 高等数学        | 831  |+-------+-----------------+------+</code></pre><p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p><pre class=" language-mysql"><code class="language-mysql">-- 在此之前向 score 插入一些数据，以便丰富查询条件。INSERT INTO score VALUES ('101', '3-105', '90');INSERT INTO score VALUES ('102', '3-105', '91');INSERT INTO score VALUES ('104', '3-105', '89');-- 查询 score 表SELECT * FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5;+-------+| c_no  |+-------+| 3-105 |+-------+</code></pre><p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p><pre class=" language-mysql"><code class="language-mysql">SELECT t_no FROM course WHERE no IN (    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5);+------+| t_no |+------+| 825  |+------+</code></pre><p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p><pre class=" language-mysql"><code class="language-mysql">SELECT name FROM teacher WHERE no IN (    -- 最终条件    SELECT t_no FROM course WHERE no IN (        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5    ));</code></pre><h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p><p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p><pre class=" language-mysql"><code class="language-mysql">-- 通过 teacher 表查询所有 `计算机系` 的教师编号SELECT no, name, department FROM teacher WHERE department = '计算机系'+-----+--------+--------------+| no  | name   | department   |+-----+--------+--------------+| 804 | 李诚   | 计算机系     || 825 | 王萍   | 计算机系     |+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号SELECT no FROM course WHERE t_no IN (    SELECT no FROM teacher WHERE department = '计算机系');+-------+| no    |+-------+| 3-245 || 3-105 |+-------+-- 根据筛选出来的课程号查询成绩表SELECT * FROM score WHERE c_no IN (    SELECT no FROM course WHERE t_no IN (        SELECT no FROM teacher WHERE department = '计算机系'    ));+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-245 |     86 || 105  | 3-245 |     75 || 109  | 3-245 |     68 || 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- NOT: 代表逻辑非SELECT * FROM teacher WHERE department = '计算机系' AND profession NOT IN (    SELECT profession FROM teacher WHERE department = '电子工程系')-- 合并两个集UNIONSELECT * FROM teacher WHERE department = '电子工程系' AND profession NOT IN (    SELECT profession FROM teacher WHERE department = '计算机系');</code></pre><h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = '3-105';+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+SELECT * FROM score WHERE c_no = '3-245';+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-245 |     86 || 105  | 3-245 |     75 || 109  | 3-245 |     68 |+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，-- 最后根据降序查询结果。SELECT * FROM score WHERE c_no = '3-105' AND degree > ANY(    SELECT degree FROM score WHERE c_no = '3-245') ORDER BY degree DESC;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 102  | 3-105 |     91 || 101  | 3-105 |     90 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 只需对上一道题稍作修改。-- ALL: 符合SQL语句中的所有条件。-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。SELECT * FROM score WHERE c_no = '3-105' AND degree > ALL(    SELECT degree FROM score WHERE c_no = '3-245');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 |+------+-------+--------+</code></pre><h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     87.6667 || 3-245 |     76.3333 || 6-166 |     81.6667 |+-------+-------------+-- 查询 score 表SELECT degree FROM score;+--------+| degree |+--------+|     90 ||     91 ||     92 ||     86 ||     85 ||     89 ||     88 ||     75 ||     79 ||     76 ||     68 ||     81 |+--------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。SELECT * FROM score a WHERE degree < (    (SELECT AVG(degree) FROM score b WHERE a.c_no = b.c_no));+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p><pre class=" language-mysql"><code class="language-mysql">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);+--------+-----------------+| name   | department      |+--------+-----------------+| 李诚   | 计算机系        || 王萍   | 计算机系        || 刘冰   | 电子工程系      || 张旭   | 电子工程系      |+--------+-----------------+</code></pre><h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 查看学生表信息SELECT * FROM student;+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 101 | 曾华      | 男  | 1977-09-01 | 95033 || 102 | 匡明      | 男  | 1975-10-02 | 95031 || 103 | 王丽      | 女  | 1976-01-23 | 95033 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 105 | 王芳      | 女  | 1975-02-10 | 95031 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 107 | 王尼玛    | 男  | 1976-02-20 | 95033 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 110 | 张飞      | 男  | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。SELECT class FROM student WHERE sex = '男' GROUP BY class HAVING COUNT(*) > 1;+-------+| class |+-------+| 95033 || 95031 |+-------+</code></pre><h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- NOT: 取反-- LIKE: 模糊查询mysql> SELECT * FROM student WHERE name NOT LIKE '王%';+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 101 | 曾华      | 男  | 1977-09-01 | 95033 || 102 | 匡明      | 男  | 1975-10-02 | 95031 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 110 | 张飞      | 男  | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+</code></pre><h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;+-----------+------+| name      | age  |+-----------+------+| 曾华      |   42 || 匡明      |   44 || 王丽      |   43 || 李军      |   43 || 王芳      |   44 || 陆军      |   45 || 王尼玛    |   43 || 张全蛋    |   44 || 赵铁柱    |   45 || 张飞      |   45 |+-----------+------+</code></pre><h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT MAX(birthday), MIN(birthday) FROM student;+---------------+---------------+| MAX(birthday) | MIN(birthday) |+---------------+---------------+| 1977-09-01    | 1974-06-03    |+---------------+---------------+</code></pre><h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM student ORDER BY class DESC, birthday;+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 110 | 张飞      | 男  | 1974-06-03 | 95038 || 103 | 王丽      | 女  | 1976-01-23 | 95033 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 107 | 王尼玛    | 男  | 1976-02-20 | 95033 || 101 | 曾华      | 男  | 1977-09-01 | 95033 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 105 | 王芳      | 女  | 1975-02-10 | 95031 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 102 | 匡明      | 男  | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+</code></pre><h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex = '男');+-------+--------------+------+| no    | name         | t_no |+-------+--------------+------+| 3-245 | 操作系统     | 804  || 6-166 | 数字电路     | 856  |+-------+--------------+------+</code></pre><h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 找出最高成绩（该查询只能有一个结果）SELECT MAX(degree) FROM score;-- 根据上面的条件筛选出所有最高成绩表，-- 该查询可能有多个结果，假设 degree 值多次符合条件。SELECT * FROM score WHERE degree = (SELECT MAX(degree) FROM score);+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 |+------+-------+--------+</code></pre><h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 首先将李军的性别作为条件取出来SELECT sex FROM student WHERE name = '李军';+-----+| sex |+-----+| 男  |+-----+-- 根据性别查询 name 和 sexSELECT name, sex FROM student WHERE sex = (    SELECT sex FROM student WHERE name = '李军');+-----------+-----+| name      | sex |+-----------+-----+| 曾华      | 男  || 匡明      | 男  || 李军      | 男  || 陆军      | 男  || 王尼玛    | 男  || 张全蛋    | 男  || 赵铁柱    | 男  || 张飞      | 男  |+-----------+-----+</code></pre><h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT name, sex, class FROM student WHERE sex = (    SELECT sex FROM student WHERE name = '李军') AND class = (    SELECT class FROM student WHERE name = '李军');+-----------+-----+-------+| name      | sex | class |+-----------+-----+-------+| 曾华      | 男  | 95033 || 李军      | 男  | 95033 || 王尼玛    | 男  | 95033 |+-----------+-----+-------+</code></pre><h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p><p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = (    SELECT no FROM course WHERE name = '计算机导论') AND s_no IN (    SELECT no FROM student WHERE sex = '男');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 104  | 3-105 |     89 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE grade (    low INT(3),    upp INT(3),    grade char(1));INSERT INTO grade VALUES (90, 100, 'A');INSERT INTO grade VALUES (80, 89, 'B');INSERT INTO grade VALUES (70, 79, 'C');INSERT INTO grade VALUES (60, 69, 'D');INSERT INTO grade VALUES (0, 59, 'E');SELECT * FROM grade;+------+------+-------+| low  | upp  | grade |+------+------+-------+|   90 |  100 | A     ||   80 |   89 | B     ||   70 |   79 | C     ||   60 |   69 | D     ||    0 |   59 | E     |+------+------+-------+</code></pre><p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p><p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p><pre class=" language-mysql"><code class="language-mysql">SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp;+------+-------+-------+| s_no | c_no  | grade |+------+-------+-------+| 101  | 3-105 | A     || 102  | 3-105 | A     || 103  | 3-105 | A     || 103  | 3-245 | B     || 103  | 6-166 | B     || 104  | 3-105 | B     || 105  | 3-105 | B     || 105  | 3-245 | C     || 105  | 6-166 | C     || 109  | 3-105 | C     || 109  | 3-245 | D     || 109  | 6-166 | B     |+------+-------+-------+</code></pre><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p><pre class=" language-mysql"><code class="language-mysql">CREATE DATABASE testJoin;CREATE TABLE person (    id INT,    name VARCHAR(20),    cardId INT);CREATE TABLE card (    id INT,    name VARCHAR(20));INSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡');SELECT * FROM card;+------+-----------+| id   | name      |+------+-----------+|    1 | 饭卡      ||    2 | 建行卡    ||    3 | 农行卡    ||    4 | 工商卡    ||    5 | 邮政卡    |+------+-----------+INSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6);SELECT * FROM person;+------+--------+--------+| id   | name   | cardId |+------+--------+--------+|    1 | 张三   |      1 ||    2 | 李四   |      3 ||    3 | 王五   |      6 |+------+--------+--------+</code></pre><p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p><pre class=" language-mysql"><code class="language-mysql">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId = card.id;</code></pre><blockquote><p>注意：<code>card</code> 的整张表被连接到了右边。</p></blockquote><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><pre class=" language-mysql"><code class="language-mysql">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      |+------+--------+--------+------+-----------+</code></pre><h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+</code></pre><h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p><pre class=" language-mysql"><code class="language-mysql">-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause'-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId = card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p><p>比如我们的银行转账：</p><pre class=" language-mysql"><code class="language-mysql">-- a -> -100UPDATE user set money = money - 100 WHERE name = 'a';-- b -> +100UPDATE user set money = money + 100 WHERE name = 'b';</code></pre><p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p><p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p><h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p><pre class=" language-mysql"><code class="language-mysql">-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            1 |+--------------+</code></pre><p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p><p>什么是回滚？举个例子：</p><pre class=" language-mysql"><code class="language-mysql">CREATE DATABASE bank;USE bank;CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20),    money INT);INSERT INTO user VALUES (1, 'a', 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+</code></pre><p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p><p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p><pre class=" language-mysql"><code class="language-mysql">-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+</code></pre><p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p><pre class=" language-mysql"><code class="language-mysql">-- 关闭自动提交SET AUTOCOMMIT = 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            0 |+--------------+</code></pre><p>将自动提交关闭后，测试数据回滚：</p><pre class=" language-mysql"><code class="language-mysql">INSERT INTO user VALUES (2, 'b', 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+</code></pre><p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p><pre class=" language-mysql"><code class="language-mysql">INSERT INTO user VALUES (2, 'b', 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+</code></pre><blockquote><p><strong>总结</strong></p><ol><li><p><strong>自动提交</strong></p><ul><li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p></li><li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p></li></ul></li><li><p><strong>手动提交</strong></p><p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p></li><li><p><strong>事务回滚</strong></p><p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p></li></ol></blockquote><p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p><pre class=" language-mysql"><code class="language-mysql">-- 转账UPDATE user set money = money - 100 WHERE name = 'a';-- 到账UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+</code></pre><p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p><pre class=" language-mysql"><code class="language-mysql">-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+</code></pre><p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p><h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p><pre class=" language-mysql"><code class="language-mysql">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+</code></pre><p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p><pre class=" language-mysql"><code class="language-mysql">BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK;</code></pre><h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p><ul><li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li><li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li><li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li><li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li></ul><h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p><ol><li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p><p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p></li><li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p><p>只能读取到其他事务<strong>已经提交的数据</strong>。</p></li><li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p><p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p></li><li><p><strong>SERIALIZABLE ( 串行化 )</strong></p><p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p></li></ol><p>查看当前数据库的默认隔离级别：</p><pre class=" language-mysql"><code class="language-mysql">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION;</code></pre><p>修改隔离级别：</p><pre class=" language-mysql"><code class="language-mysql">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED               |+--------------------------------+</code></pre><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p><pre class=" language-mysql"><code class="language-mysql">INSERT INTO user VALUES (3, '小明', 1000);INSERT INTO user VALUES (4, '淘宝店', 1000);SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+</code></pre><p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p><pre class=" language-mysql"><code class="language-mysql">-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+</code></pre><p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p><h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p><pre class=" language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED                 |+--------------------------------+</code></pre><p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p><pre class=" language-mysql"><code class="language-mysql">-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+</code></pre><p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p><pre class=" language-mysql"><code class="language-mysql">-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, 'c', 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+|  820.0000  |+------------+</code></pre><p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p><pre class=" language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                |+--------------------------------+</code></pre><p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 小张 - 成都</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 小王 - 北京</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 小张 - 成都</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></code></pre><p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p><p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span><span class="token operator">|</span> id <span class="token operator">|</span> name      <span class="token operator">|</span> money <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">a</span>         <span class="token operator">|</span>   <span class="token number">900</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">b</span>         <span class="token operator">|</span>  <span class="token number">1100</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> 小明      <span class="token operator">|</span>  <span class="token number">1000</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> 淘宝店    <span class="token operator">|</span>  <span class="token number">1000</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span> <span class="token number">c</span>         <span class="token operator">|</span>   <span class="token number">100</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span></code></pre><p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) <strong>，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的</strong>，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p><p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'</span></code></pre><p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p><pre class=" language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE                   |+--------------------------------+</code></pre><p>还是拿小张和小王来举例：</p><pre class=" language-mysql"><code class="language-mysql">-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 ||  6 | d         |  1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, '王小花', 1000);</code></pre><p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p><p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p><p>除开null</p><p>select name from customer where ifnull(referee_id, 0)&lt;&gt; 2</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2023/02/10/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/02/10/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程包括以下这几个状态：</p><p>创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、消亡（dead）</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/682616-20161115183635779-1231872003.jpg" alt="img" style="zoom: 67%;" /><p>注意点：</p><p>1、当线程进入就绪状态后，不代表立刻就能获取CPU执行时间</p><p>2、如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p><p>3、调用yield方法并不会让线程进入阻塞状态，而是让线程<strong>重回就绪</strong>状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。</p><p>4、wait方法会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限。</p><p>5、调用join方法实际上是调用了Object的wait方法。由于wait方法会让线程释放对象锁，所以join方法同样会让线程释放对一个对象持有的锁。</p><h3 id="Thread类中常用的方法："><a href="#Thread类中常用的方法：" class="headerlink" title="Thread类中常用的方法："></a>Thread类中常用的方法：</h3><p>以下是关系到线程 <em>运行状态</em> 的几个方法：</p><p>1）start方法</p><p>start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。</p><p>2）run方法</p><p>run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意<strong>，继承Thread类必须重写run方法</strong>，在run方法中定义具体要执行的任务。</p><p>3）sleep方法</p><p>sleep方法有两个重载版本：</p><pre><code>sleep(long millis)     //参数为毫秒sleep(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</code></pre><p>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。</p><p>但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。</p><p>4）yield方法</p><p>调用yield方法会让<strong>当前线程交出CPU权限</strong>，让CPU去执行其他的线程。它跟sleep方法类似，同样<strong>不会释放锁</strong>。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让<u>拥有相同优先级的线程</u>有获取CPU执行时间的机会。</p><p>5）join方法</p><p>join方法有三个重载版本：</p><pre><code>join()join(long millis)     //参数为毫秒join(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</code></pre><p>假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的事件。</p><p>6）interrupt方法</p><p>单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。</p><p>直接调用interrupt方法可以中断处于阻塞状态的线程，但不能中断正在运行中的线程。</p><p>如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志位置为true，那么可以通过调用isInterrupted()判断中断标志是否被置位来中断线程的执行。</p><p>7）stop方法</p><p>stop方法已经是一个废弃的方法，它是一个不安全的方法。因为调用stop方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以stop方法基本是不会被用到的。</p><p>8）destroy方法</p><p>destroy方法也是废弃的方法。基本不会被使用到。</p><h3 id="以下是关系到线程属性的几个方法"><a href="#以下是关系到线程属性的几个方法" class="headerlink" title="以下是关系到线程属性的几个方法:"></a>以下是关系到线程属性的几个方法:</h3><p>1）getId</p><p>用来得到线程ID</p><p>2）getName和setName</p><p>用来得到或者设置线程名称。</p><p>3）getPriority和setPriority</p><p>用来获取和设置线程优先级。</p><p>4）setDaemon和isDaemon</p><p>用来设置线程是否成为守护线程和判断线程是否是守护线程。</p><p>​    守护线程和用户线程的区别在于：</p><p>​    守护线程依赖于创建它的线程，而用户线程则不依赖。</p><p>​    举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p><p>5）public final boolean isAlive()<br>测试线程是否处于活动状态。</p><p>6）public static void yield()<br>暂停当前正在执行的线程对象，并执行其他线程</p><p>7）currentThread()</p><p>用来获取当前线程</p><h3 id="sleep-和-wait-方法解释"><a href="#sleep-和-wait-方法解释" class="headerlink" title="sleep 和 wait 方法解释"></a>sleep 和 wait 方法解释</h3><p>sleep()方法是Thread类里面的，主要的意义就是让当前线程停止执行，让出cpu给其他的线程，但是不会释放对象锁资源以及监控的状态，当指定的时间到了之后又会自动恢复运行状态。</p><p>wait()方法是Object类里面的，主要的意义就是让线程放弃当前的对象的锁，进入等待此对象的等待锁定池，只有针对此对象调动notify方法后本线程才能够进入对象锁定池准备获取对象锁进入运行状态。</p><h3 id="start-和-run-方法解释"><a href="#start-和-run-方法解释" class="headerlink" title="start 和 run 方法解释"></a><strong>start 和 run 方法解释</strong></h3><p>1、start：用start方法来启动线程，真正实现了多线程运行，这时<u>无需等待run方法体代码执行完毕而直接继续执行下面的代码</u>。</p><p>通过调用Thread类的start()方法来启动一个线程，这时此线程处于<strong>就绪（可运行）</strong>状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。<br>2、run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然<strong>只有主线程</strong>这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p><p>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/716271-20170320112245721-1831918220.jpg" alt="img" style="zoom:67%;" /><h2 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h2><p>Java 提供了三种创建线程的方法：</p><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。</li></ul><p><strong>实现并启动线程有两种方法</strong><br>1、写一个类继承自Thread类，重写run方法。用start方法启动线程<br>2、写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动</p><p><strong>多线程原理：</strong></p><p><strong>多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发</strong></p><p>相当于玩游戏机，只有一个游戏机（cpu），可是有很多人要玩，于是，start是排队！等CPU选中你就是轮到你，你就run（），当CPU的运行的时间片执行完，这个线程就继续排队，等待下一次的run（）</p><h3 id="通过实现-Runnable-接口来创建线程"><a href="#通过实现-Runnable-接口来创建线程" class="headerlink" title="通过实现 Runnable 接口来创建线程"></a>通过实现 Runnable 接口来创建线程</h3><p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p><p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</p><p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p><p>Thread 定义了几个构造方法，下面的这个是我们经常使用的：</p><pre class=" language-java"><code class="language-java"><span class="token function">Thread</span><span class="token punctuation">(</span>Runnable threadOb<span class="token punctuation">,</span>String threadName<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p><p>新线程创建之后，你调用它的 start() 方法它才会运行。</p><h3 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h3><p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p><p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p><p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p><h3 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h3><ul><li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li><li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li></ul><h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul><li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li><li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2023/02/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/02/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><strong>[ABC]</strong></td><td align="left">匹配 <strong>[…]</strong> 中的所有字符<img src="https://www.runoob.com/wp-content/uploads/2014/03/E691DDE1-E5CB-4EA8-8D16-759BD0D2B09D.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp5" target="_blank" rel="noopener">尝试一下 »</a></td></tr><tr><td align="left"><strong>[^ABC]</strong></td><td align="left">匹配除了 <strong>[…]</strong> 中字符的所有字符，<img src="https://www.runoob.com/wp-content/uploads/2014/03/ED971D92-30F4-4768-A2C7-02A84A3A9DEB.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp6" target="_blank" rel="noopener">尝试一下 »</a></td></tr><tr><td align="left"><strong>[A-Z]</strong></td><td align="left">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。<img src="https://www.runoob.com/wp-content/uploads/2014/03/C5E357BD-65E3-4EB3-9D80-10D096F19287.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp7" target="_blank" rel="noopener">尝试一下 »</a></td></tr><tr><td align="left"><strong>.</strong></td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。<img src="https://www.runoob.com/wp-content/uploads/2014/03/0FD7E77D-38A7-43BC-B51A-7DBA23A77756.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp8" target="_blank" rel="noopener">尝试一下 »</a></td></tr><tr><td align="left"><strong>[\s\S]</strong></td><td align="left">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。<img src="https://www.runoob.com/wp-content/uploads/2014/03/47CA6C59-64CF-433A-909E-1E342349A4E0.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp9" target="_blank" rel="noopener">尝试一下 »</a></td></tr><tr><td align="left"><strong>\w</strong></td><td align="left">匹配字母、数字、下划线。等价于 [A-Za-z0-9_]<img src="https://www.runoob.com/wp-content/uploads/2014/03/F35A5971-3519-4CAE-8BEC-9DE8F4A55257.jpg" alt="img"  /></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp10" target="_blank" rel="noopener">尝试一下 »</a></td></tr></tbody></table><h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 <em>***，**runo*ob</em>* 匹配字符串 <strong>runo*ob</strong>。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符*<em>*</em> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th align="left">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td></tr><tr><td align="left">( )</td><td align="left">标记一个<u>子表达式</u>的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式<strong>零次或多次</strong>。要匹配 * 字符，请使用 *。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式<strong>一次或多次</strong>。要匹配 + 字符，请使用 +。</td></tr><tr><td align="left">.</td><td align="left">匹配<strong>除换行符 \n 之外</strong>的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td align="left">[</td><td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式<strong>零次或一次</strong>，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td align="left">\</td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td align="left">{</td><td align="left">标记<u>限定符表达式</u>的开始。要匹配 {，请使用 {。</td></tr><tr><td align="left">|</td><td align="left">指明两项之间的一个选择。要匹配 |，请使用 |。</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。</td></tr></tbody></table><p>\b单词边界元字符确保只检测整个单词。否则，诸如 “is issued” 或 “this is” 之类的词组将不能正确地被此表达式识别。</p><p> \i 标记指定不区分大小写。</p><p>全局标记 \g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配</p><p>多行标记 \m 指定换行符的两边可能出现潜在的匹配。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p><p><strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p><h2 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h2><ul><li>数字：<strong>^[0-9]*$</strong></li><li>n位的数字：<strong>^\d{n}$</strong></li><li>至少n位的数字<strong>：^\d{n,}$</strong></li><li>m-n位的数字：<strong>^\d{m,n}$</strong></li><li>零和非零开头的数字：<strong>^(0|[1-9][0-9]*)$</strong></li><li>非零开头的最多带两位小数的数字：<strong>^([1-9][0-9]*)+(.[0-9]{1,2})?$</strong></li><li>带1-2位小数的正数或负数：<strong>^(-)?\d+(.\d{1,2})$</strong></li><li>正数、负数、和小数：<strong>^(-|+)?\d+(.\d+)?$</strong></li><li>有两位小数的正实数：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>有1~3位小数的正实数：<strong>^[0-9]+(.[0-9]{1,3})?$</strong></li><li>非零的正整数：<strong>^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^+?[1-9][0-9]*$</strong></li><li>非零的负整数：<strong>^-[1-9][]0-9”*$ 或 ^-[1-9]\d*$</strong></li><li>非负整数：<strong>^\d+$ 或 ^[1-9]\d*|0$</strong></li><li>非正整数：<strong>^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</strong></li><li>非负浮点数：<strong>^\d+(.\d+)?$ 或 ^[1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0$</strong></li><li>非正浮点数：<strong>^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d*.\d*|0.\d*[1-9]\d*))|0?.0+|0$</strong></li><li>正浮点数：<strong>^[1-9]\d*.\d*|0.\d*[1-9]\d*$ 或 ^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$</strong></li><li>负浮点数：<strong>^-([1-9]\d*.\d*|0.\d*[1-9]\d*)$ 或 ^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$</strong></li><li>浮点数：<strong>^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0)$</strong></li></ul><hr><h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><ul><li>汉字：<strong>^[\u4e00-\u9fa5]{0,}$</strong></li><li>英文和数字：<strong>^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</strong></li><li>长度为3-20的所有字符：<strong>^.{3,20}$</strong></li><li>由26个英文字母组成的字符串：<strong>^[A-Za-z]+$</strong></li><li>由26个大写英文字母组成的字符串：<strong>^[A-Z]+$</strong></li><li>由26个小写英文字母组成的字符串：<strong>^[a-z]+$</strong></li><li>由数字和26个英文字母组成的字符串：<strong>^[A-Za-z0-9]+$</strong></li><li>由数字、26个英文字母或者下划线组成的字符串：<strong>^\w+$ 或 ^\w{3,20}$</strong></li><li>中文、英文、数字包括下划线：<strong>^[\u4E00-\u9FA5A-Za-z0-9_]+$</strong></li><li>中文、英文、数字但不包括下划线等符号：<strong>^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</strong></li><li>可以输入含有^%&amp;’,;=?$&quot;等字符：**[^%&amp;’,;=?$\x22]+**</li><li>禁止输入含有<del>的字符：**[^</del>]+**</li></ul><hr><h2 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h2><ul><li>Email地址：<strong>^\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*$</strong></li><li>域名：**[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.?**</li><li>InternetURL：**[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$**</li><li>手机号码：<strong>^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$</strong></li><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<strong>^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$</strong></li><li>国内电话号码(0511-4405222、021-87888822)：<strong>\d{3}-\d{8}|\d{4}-\d{7}</strong></li><li>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: <strong>((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)</strong></li><li>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：**(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)**</li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<strong>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</strong></li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<strong>^[a-zA-Z]\w{5,17}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：<strong>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：<strong>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</strong></li><li>日期格式：<strong>^\d{4}-\d{1,2}-\d{1,2}</strong></li><li>一年的12个月(01～09和1～12)：<strong>^(0?[1-9]|1[0-2])$</strong></li><li>一个月的31天(01～09和1～31)：<strong>^((0?[1-9])|((1|2)[0-9])|30|31)$</strong></li><li>钱的输入格式：<ol><li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<strong>^[1-9][0-9]*$</strong></li><li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：<strong>^(0|[1-9][0-9]*)$</strong></li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<strong>^(0|-?[1-9][0-9]*)$</strong></li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：<strong>^[0-9]+(.[0-9]+)?$</strong></li><li>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<strong>^[0-9]+(.[0-9]{1,2})?$</strong></li><li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<strong>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</strong></li><li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：<strong>^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</strong></li><li>备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li></ol></li><li>xml文件：<strong>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</strong></li><li>中文字符的正则表达式：**[\u4e00-\u9fa5]**</li><li>双字节字符：**[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))**</li><li>空白行的正则表达式：<strong>\n\s*\r (可以用来删除空白行)</strong></li><li>HTML标记的正则表达式：**&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)**</li><li>腾讯QQ号：**[1-9][0-9]{4,} (腾讯QQ号从10000开始)**</li><li>中国邮政编码：**[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)**</li><li>IPv4地址：**((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}**</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket</title>
      <link href="/2023/02/10/Socket/"/>
      <url>/2023/02/10/Socket/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p><strong>TCP/IP、UDP</strong></p><ol><li><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p></li><li><p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20190718154523875.png" style="zoom:80%;" /><p><strong>Socket是什么呢？</strong></p><pre><code>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。</code></pre><p>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20190718154556909.png" alt="img"  /><p>先从服务器端说起。</p><p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</p><p>在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)</p><p>如果连接成功，这时客户端与服务器端的连接就建立了。</p><p>客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><h1 id="1、网络中进程之间如何通信？"><a href="#1、网络中进程之间如何通信？" class="headerlink" title="1、网络中进程之间如何通信？"></a>1、网络中进程之间如何通信？</h1><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p><p>其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。</p><p>利用三元组（ip地址，协议，端口）就可以标识网络的进程了。</p><h1 id="2、socket的基本操作"><a href="#2、socket的基本操作" class="headerlink" title="2、socket的基本操作"></a>2、socket的基本操作</h1><p>socket是“open—write/read—close”模式的一种实现，socket提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p><h2 id="2-1、socket-函数"><a href="#2-1、socket-函数" class="headerlink" title="2.1、socket()函数"></a>2.1、socket()函数</h2><pre class=" language-vim"><code class="language-vim">int <span class="token function">socket</span><span class="token punctuation">(</span>int domain<span class="token punctuation">,</span> int type<span class="token punctuation">,</span> int protocol<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字</p><p>而<strong>socket()<strong>用于创建一个socket描述符（</strong>socket descriptor</strong>），它唯一标识一个socket。</p><p>这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li><p><strong>domain</strong>：即<strong>协议域</strong>，又称为协议族（family）。</p><p>常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。</p><p>协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p></li><li><p><strong>type</strong>：指定socket<strong>类型</strong>。</p><p>常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</p></li><li><p><strong>protocol</strong>：故名思意，就是<strong>指定协议</strong>。</p><p>常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</p></li></ul><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h2 id="2-2、bind-函数"><a href="#2-2、bind-函数" class="headerlink" title="2.2、bind()函数"></a>2.2、bind()函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。</p><p>例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><pre class=" language-vim"><code class="language-vim">int <span class="token function">bind</span><span class="token punctuation">(</span>int sockfd<span class="token punctuation">,</span> const struct sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即socket描述字，它是通过socket()函数创建，唯一标识一个socket。<strong>bind()函数就是将给这个描述字绑定一个名字</strong></p></li><li><p>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><pre class=" language-c++"><code class="language-c++">struct sockaddr_in {    sa_family_t    sin_family;     in_port_t      sin_port;       struct in_addr sin_addr;   };struct in_addr {    uint32_t       s_addr;     };</code></pre><p>ipv6对应的是：</p><pre class=" language-c++"><code class="language-c++">struct sockaddr_in6 {     sa_family_t     sin6_family;        in_port_t       sin6_port;          uint32_t        sin6_flowinfo;      struct in6_addr sin6_addr;          uint32_t        sin6_scope_id;  };struct in6_addr {     unsigned char   s6_addr[16];    };</code></pre><p>Unix域对应的是：</p><pre class=" language-c++"><code class="language-c++">#define UNIX_PATH_MAX    108struct sockaddr_un {     sa_family_t sun_family;                    char        sun_path[UNIX_PATH_MAX];   };</code></pre></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；</p><p>而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。</p><p>这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p><h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><p><strong>主机字节序</strong></p><p>就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。</p><p>　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。高高低低——小端</p><p>　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p><strong>网络字节序</strong>：</p><p>4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。</p><p>即大端字节序。<strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong></p><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>所以： 在将一个地址绑定到socket的时候，请<strong>先将主机字节序转换成为网络字节序</strong>，将其转化为网络字节序再赋给socket。</p><h2 id="2-3、listen-、connect-函数"><a href="#2-3、listen-、connect-函数" class="headerlink" title="2.3、listen()、connect()函数"></a>2.3、listen()、connect()函数</h2><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket</p><p>如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><pre class=" language-c++"><code class="language-c++">int listen(int sockfd, int backlog);int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的<strong>最大连接个数</strong>。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为<strong>被动类型的，等待客户的连接请求</strong>。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p><h2 id="2-4、accept-函数"><a href="#2-4、accept-函数" class="headerlink" title="2.4、accept()函数"></a>2.4、accept()函数</h2><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。</p><p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。</p><p>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。</p><p>之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><pre class=" language-c++"><code class="language-c++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accpet成功，那么其返回值是<strong>由内核自动生成的一个全新的描述字</strong>，代表与返回客户的TCP连接。</p><p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为<strong>监听socket描述字</strong>；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，<strong>它在该服务器的生命周期内一直存在</strong>。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p><h2 id="2-5、read-、write-等函数"><a href="#2-5、read-、write-等函数" class="headerlink" title="2.5、read()、write()等函数"></a>2.5、read()、write()等函数</h2><p>至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信。</p><p>网络I/O操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数</p><p>实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：</p><pre class=" language-c++"><code class="language-c++">#include ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count);#include #include ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,                      const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                        struct sockaddr *src_addr, socklen_t *addrlen);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</code></pre><p>read函数是负责从fd中读取内容。</p><p>​    当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。</p><p>​    如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd。</p><p>​    成功时返回写的字节数。失败时返回-1，并设置errno变量。</p><p>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</p><p>​    1)write的返回值大于0，表示写了部分或者是 全部的数据。</p><p>​    2)返回的值小于0，此时出现了错误。</p><p>​    如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p><h2 id="2-6、close-函数"><a href="#2-6、close-函数" class="headerlink" title="2.6、close()函数"></a>2.6、close()函数</h2><p>完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><pre class=" language-c++"><code class="language-c++">#include int close(int fd);</code></pre><p>close一个TCP socket的缺省行为时把该socket标记为已关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p><h1 id="3、socket中TCP的三次握手建立连接详解"><a href="#3、socket中TCP的三次握手建立连接详解" class="headerlink" title="3、socket中TCP的三次握手建立连接详解"></a>3、socket中TCP的三次握手建立连接详解</h1><p>tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p><p><a href="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0NzYyODYucG5n" alt="image"></a></p><p>socket中发送的TCP三次握手</p><ul><li>当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；</li><li>服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；</li><li>客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；</li><li>服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</li></ul><h1 id="4、socket中TCP的四次握手释放连接详解"><a href="#4、socket中TCP的四次握手释放连接详解" class="headerlink" title="4、socket中TCP的四次握手释放连接详解"></a>4、socket中TCP的四次握手释放连接详解</h1><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。</p><p>现在介绍socket中的四次握手释放连接的过程</p><p><a href="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0OTQ2OTMucG5n" alt="image"></a></p><p>socket中发送的TCP四次握手</p><ul><li><p>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</p></li><li><p>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</p></li><li><p>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</p></li><li><p>接收到这个FIN的源发送端TCP对它进行确认。</p><p>这样每个方向上都有一个FIN和ACK。</p></li></ul><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20190718155008892.png" alt="img"></p></li></ol><p>小明住在上海市长江路幸福小区5#666，现在小明在京东上面买了一部小米10Pro。京东在接到小米的订单后，工作人员从仓库中找到一部小米10Pro（应用层）。工作人员将手机打包好， 交给了京东物流（传输层）。接下来手机就到了转运中心（路由器），转运中心根据时间，成本等一系列因素决定下一步该发往哪一个转运中心(网络层)。决定好接下来发往哪一个转运中心后就开始用货车运输了，那么运输的过程就是数据链路层了，链路层负责将数据从一个端点送到另一个端点。那么货车行驶的道路就是物理层。几经周转，手机安全地送到了小明手上。</p><p>我们将一个小区比作一台计算机，一台计算机里面跑了很多程序，怎么区分程序呢，用的是端口，就好像小区用门牌号区分每一户人家一样。手机送到小明家了，怎么进去呢？从大门进啊，怎么找到大门呢？门牌号呀。不就相当于从互联网来的数据找到接收端计算机后再根据端口判断应该给哪一个程序一样吗。小明家的入口就可以用小区地址+门牌号进行唯一表示，那么同样的道理，程序也可以用IP+端口号进行唯一标识。那么这个程序的入口就被称作Socket。</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/2023/02/10/%E7%BC%93%E5%AD%98/"/>
      <url>/2023/02/10/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>缓存是将==请求的结果==存储在与<strong>原始存储位置</strong>或<strong>临时存储位置</strong>不同的位置的过程，可以避免重复执行相同的操作。<br>基本上，缓存是文件和数据的==临时存储==，从这个新位置访问数据会更快。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>Web浏览器缓存HTML、CSS、JS和图像，以便在再次请求时更快的访问网站。 </li><li>==CDN存储静态文件==，有助于减少延迟。</li><li>DNS用于获取查询的IP地址，查询结果可以存储在缓存中，因此当我们多次请求IP地址时，==不必再次执行DNS查询==，从而可以更快的访问网页。<h2 id="回收机制（Eviction-policy）"><a href="#回收机制（Eviction-policy）" class="headerlink" title="回收机制（Eviction policy）"></a>回收机制（Eviction policy）</h2>当缓存用完时，需要删除旧缓存项，从而可以缓存新内容。事实上，删除最近最少使用的对象是最流行的方法之一，这个解决方案可以优化缓存中命中请求资源的概率。</li><li><strong>随机替换（RR，Random Replacement）</strong>：正如其字面意思，我们可以随机删除一个条目。</li><li><strong>最少使用次数（LFU，Least frequently used）</strong>：记录一个条目被请求的频率，并删除最不频繁使用的条目。</li><li><strong>最近最少使用（LRU，Least Recently Used）</strong>：在LRU中，删除最近使用次数最少的条目。</li><li><strong>先入先出（FIFO，First In First Out）</strong>：FIFO算法保存对象加载到缓存中的顺序。如果缓存没有命中，从头部取出一个或多个对象，并将一个新的缓存对象插入到队尾。如果缓存命中，保持缓存不变。</li></ul><h2 id="不同的缓存方法"><a href="#不同的缓存方法" class="headerlink" title="不同的缓存方法"></a>不同的缓存方法</h2><ol><li><strong>应用服务器缓存（Application server cache）</strong>：我们可以==直接在应用层==缓存数据。每次向服务发出请求时，如果存在缓存的本地数据，可以快速返回。如果不在缓存中，将从数据库查询数据。</li><li><strong>全局缓存（Global caches）</strong>：在全局缓存中，==所有节点使用相同的单一缓存空间==，每个应用节点以与本地节点相同的方式查询缓存。</li><li><strong>分布式缓存（Distributed cache）</strong>：通常使用==一致性哈希算法==分割缓存数据，==每个节点都拥有部分缓存数据==。如果请求节点正在搜索某一段数据，那么可以很容易的使用哈希函数从分布式缓存中定位信息，以确定数据是否可用。</li><li><strong>内容分发网络（CDN，Content Distribution Network）</strong>:如果我们正在开发的框架还没有大到足以拥有自己的CDN，而我们的页面又需要大量静态媒体，那么租用CDN是最好的选择。使用像apache这样的轻量级HTTP服务器，可以为不同的子域（如“blog.enjoyalgorithms.com”）提供静态媒体服务，并将DNS从我们的服务器切到CDN层。</li><li><strong>客户端缓存（Client-Side Caches）</strong>：客户端缓存直接在浏览器或其他客户端（例如中间网络缓存）中缓存以前请求的文件数据。</li><li><strong>ISP层缓存（ISP layer cache）</strong>:ISP缓存的工作方式与浏览器缓存基本相同。一旦你访问了一个网站，你的ISP可能会缓存这些页面，这样当你下次访问它们时，加载速度会更快。这样做的主要问题是，与浏览器缓存不同，你不能删除这些临时文件，必须等待ISP的缓存过期才能请求文件的新副本。</li></ol><h2 id="缓存失效（Cache-Invalidation）"><a href="#缓存失效（Cache-Invalidation）" class="headerlink" title="缓存失效（Cache Invalidation）"></a>缓存失效（Cache Invalidation）</h2><p>如果数据库中的数据被更改，它在缓存中应该是无效的，否则可能会触发不一致的应用程序操作。当前主要有三种缓存系统设计方案：</p><ol><li><strong>Write through cache</strong>：通过缓存执行写操作，只有当写DB和缓存都成功时，写操作才被验证为成功。在缓存和存储之间，将拥有完全的数据一致性。在崩溃、电源故障或其他系统干扰的情况下，任何东西都不会丢失。然而，在这种情况下，因为要写入两个不同的系统，写入延迟会更高。</li><li><strong>Write around cache</strong>：写操作绕过缓存，直接写入DB。在缓存读取过程中，由于数据不在缓存中，cache miss会增加，缓存设备需要从数据库中读取信息。因此，在快速写入和重新读取数据的应用程序中，这可能会导致更高的读延迟。</li><li><strong>Write back cache</strong>：写操作直接发送给缓存层，一旦缓存的写操作完成，就认为写操作成功。然后缓存异步的将写操作同步到DB。对于写密集型应用，这可以降低写延迟以及提高写吞吐量。但是，因为缓存是写入数据的唯一副本，如果缓存层被关闭，有可能丢失数据。通过在缓存中部署多个可以识别写操作的副本，我们可以尽量减少数据丢失的风险。</li></ol><h1 id="缓存的好处"><a href="#缓存的好处" class="headerlink" title="缓存的好处"></a>缓存的好处</h1><ol><li><strong>提高应用程序性能</strong>—缓存可以用来==提高系统性能和降低API延迟==。</li><li><strong>降低数据库成本</strong>——缓存会占用缓存服务器的额外流量，从而==减少数据库流量==，最终降低数据库成本。</li><li><strong>减轻后端负载</strong>——将相同的请求流量从主服务器卸载到缓存服务器将减轻后端负载。</li><li>**增加读吞吐量(IOPS)**——缓存服务器对缓存数据的响应比主服务器快得多，这增加了读吞吐量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Hexo部署到云服务器(CentOS)</title>
      <link href="/2023/02/09/%E5%B0%86Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2023/02/09/%E5%B0%86Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1. 安装git"></a>1. 安装git</h2><p>输入下面命令即可安装</p><pre class=" language-bash"><code class="language-bash">//方法一：<span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">git</span>//方法二：yum <span class="token function">install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum <span class="token function">install</span> -y <span class="token function">git</span></code></pre><p>查看git版本</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> --version </code></pre><h2 id="2-配置参数"><a href="#2-配置参数" class="headerlink" title="2. 配置参数"></a>2. 配置参数</h2><p>接下来在git中配置自己的名称和电子邮件地址，可以通过使用以下命令来完成此操作：</p><pre class=" language-.vim"><code class="language-.vim">git config --global user.name "用户名" git config --global user.email "用户邮箱"</code></pre><p>可以通过下面命令查看是否正确配置。</p><pre class=" language-.vim"><code class="language-.vim">git config --list</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209171308239.png" alt="git安装与配置" style="zoom: 80%;" /><h2 id="3-创建一个ssh-key"><a href="#3-创建一个ssh-key" class="headerlink" title="3.创建一个ssh key"></a>3.创建一个ssh key</h2><p>作用：将电脑和github账号联系在一起的密钥，可以十分方便的通过git上传代码。</p><p>获取密钥的方法如下：</p><p>首先在命令行输入cd ~/.ssh，第一次配置会显示没有那个文件或目录，这是正常现象。</p><p>然后在命令行输入ssh-keygen -t rsa -C “邮箱地址”，接下来连按三次回车就可以了。</p><p>命令行代码如下：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209171948768.png" alt="创建ssh key" style="zoom:80%;" /><p>密钥就创建成功了。</p><p>打开/root/.ssh文件夹下id_rsa.pub文件，复制里面的内容</p><h2 id="4-登录GitHub添加ssh-key"><a href="#4-登录GitHub添加ssh-key" class="headerlink" title="4.登录GitHub添加ssh key"></a>4.登录GitHub添加ssh key</h2><p>选择setting里面的SSH and GPG keys选项</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209172417818.png" alt="SSH and GPG keys"></p><p>点击New SSH keys后界面如下图所示，Title是给密钥起一个名字，随便起一个就行，之后把刚刚复制的密钥填写在下边的大框里，点击Add SSH keys即可。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209172508480.png" alt="New SSH keys"></p><h2 id="5-创建用户并配置初始化仓库"><a href="#5-创建用户并配置初始化仓库" class="headerlink" title="5.创建用户并配置初始化仓库"></a>5.创建用户并配置初始化仓库</h2><p>创建一个 git 仓库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">useradd</span> <span class="token function">git</span> <span class="token function">passwd</span> <span class="token function">git</span> // 设置密码<span class="token function">su</span> <span class="token function">git</span> // 这步很重要，避免文件权限的各种问题<span class="token function">cd</span> /home/git/<span class="token function">mkdir</span> -p project/hexo-blog // 项目存在的真实目录,存放hexo静态文件<span class="token function">mkdir</span> repos <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> repos // 放置git仓库的文件夹<span class="token function">git</span> init --bare hexo-blog-repo.git// 创建一个裸露的仓库</code></pre><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209175642145.png" alt="配置初始化仓库"></p><h2 id="6-创建钩子函数"><a href="#6-创建钩子函数" class="headerlink" title="6.创建钩子函数"></a>6.创建钩子函数</h2><p> 新建文件夹hexo-blog-repo.git 在文件夹中创建钩子post-receive，把提交到 git 仓库的文件同步到 home/hexo文件夹中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> hexo-blog-repo.git/hooks //进入hooks文件夹vim post-receive //创建hook钩子函数文件<span class="token punctuation">(</span>git提交时自动部署<span class="token punctuation">)</span>，</code></pre><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209175759880.png" alt="钩子函数"></p><p>编写内容如下：（i进入insert模式，编写完毕后按Esc，连按两次Z保存退出）</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> --work-tree<span class="token operator">=</span>/home/git/projects/hexo-blog --git-dir<span class="token operator">=</span>/home/git/repos/hexo-blog-repo checkout -f</code></pre><h2 id="7-修改权限"><a href="#7-修改权限" class="headerlink" title="7.修改权限"></a>7.修改权限</h2><p>chmod用法： 用来修改某个目录或文件的访问权限</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> +x post-receive<span class="token keyword">exit</span> // 退出到 root 登录<span class="token function">chown</span> -R git:git /home/git/repos/hexo-blog-repo.git // 添加权限</code></pre><h2 id="8-测试能否拉取"><a href="#8-测试能否拉取" class="headerlink" title="8.测试能否拉取"></a>8.测试能否拉取</h2><p>在本地打开一个终端，以 ssh 的方式登录云服务器</p><p>server_ip：用户的服务器ip</p><pre class=" language-shell"><code class="language-shell">ssh -v git@server_ip// 输入密码 即可成功登录云服务器</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230210135945164.png" alt=" ssh 登录云服务器" style="zoom: 80%;" /><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone git@server_ip:/home/git/repos/hexo-blog-repo.git</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209180030554.png" alt="clone结果" style="zoom:80%;" /><h2 id="9-建立客户端与服务器的-SSH-免密连接"><a href="#9-建立客户端与服务器的-SSH-免密连接" class="headerlink" title="9.建立客户端与服务器的 SSH 免密连接"></a>9.建立客户端与服务器的 SSH 免密连接</h2><p>创建 authorized_keys 以及配置权限</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /home/git/.ssh<span class="token function">touch</span> authorized_keys  //存放客户端的ssh公钥<span class="token punctuation">(</span>id_rsa.pub<span class="token punctuation">)</span><span class="token function">chmod</span> 600 authorized_keys   //配置权限</code></pre><h2 id="10-生成密钥对（已有的请忽略）"><a href="#10-生成密钥对（已有的请忽略）" class="headerlink" title="10.生成密钥对（已有的请忽略）"></a>10.生成密钥对（已有的请忽略）</h2><p>进入你本机的(windows) c:/Users/电脑名称/.ssh 文件夹下，查看是否有名为 <code>id_rsa.pub</code> 和 <code>id_rsa</code> 的文件：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209180411071.png" alt="本机密钥对" style="zoom:67%;" /><p>如果有，请跳过下面 <strong>生成密钥</strong> 这一步：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa</code></pre><blockquote><p>中途不管你提示啥，一直Enter就是了，生成成功的话会在控制台打印出一个图案</p></blockquote><h2 id="11-建立-SSH-信任关系（免密登录）"><a href="#11-建立-SSH-信任关系（免密登录）" class="headerlink" title="11.建立 SSH 信任关系（免密登录）"></a>11.建立 SSH 信任关系（免密登录）</h2><pre class=" language-bash"><code class="language-bash">ssh-copy-id -i C:/Users/电脑用户名/.ssh/id_rsa.pub git@server_ip<span class="token function">ssh</span> git@server_ip // 测试能否登录</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209200559093.png" alt="登录情况" style="zoom: 80%;" /><p>注意本地 ssh-keygen生成密钥对时<strong>最好不要对密钥对进行重命名</strong></p><h2 id="12-限制-git-用户的权限"><a href="#12-限制-git-用户的权限" class="headerlink" title="12.限制 git 用户的权限"></a>12.限制 git 用户的权限</h2><p>为了安全起见，最好是将 git 用户的权限设置为只能执行 <strong>git clone , git push</strong> 命令等等：</p><p>/usr/bin/git-shell</p><pre class=" language-bash"><code class="language-bash">// 查看 git-shell 是否在登录方式里面<span class="token function">cat</span> /etc/shells // 查看是否安装<span class="token function">which</span> git-shell//添加第2步显示出来的路径，通常为 /usr/bin/git-shellvim /etc/shells</code></pre><p>/etc/shells内容：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209201858460.png" alt="/etc/shells内容" style="zoom:80%;" /><p>同时修改 /etc/passwd 文件内容，更改权限：</p><pre class=" language-bash"><code class="language-bash">将原来的:git:x:1002:1002::/home/git:/bin/bash //原来的修改为:git:x:1001:1001::/home/git:/usr/bin/git-shell //修改之后</code></pre><h2 id="13-安装配置-Nginx"><a href="#13-安装配置-Nginx" class="headerlink" title="13.安装配置 Nginx"></a>13.安装配置 Nginx</h2><h4 id="13-1安装"><a href="#13-1安装" class="headerlink" title="13.1安装"></a>13.1安装</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src <span class="token function">wget</span> <span class="token string">"http://nginx.org/download/nginx-1.17.8.tar.gz"</span> //下载安装文件<span class="token function">tar</span> -xvzf nginx-1.17.8.tar.gz -C <span class="token punctuation">..</span>/<span class="token function">cd</span> <span class="token punctuation">..</span>/nginx-1.17.8./configure --prefix<span class="token operator">=</span>/usr/local/nginx-webServer --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span> // 编译安装<span class="token function">alias</span> nginx<span class="token operator">=</span><span class="token string">'/usr/local/nginx-webServer/sbin/nginx'</span> //取别名为nginx，方便调用</code></pre><p>根据上面的步骤，安装完成，在控制台输入</p><h4 id="13-2查看版本"><a href="#13-2查看版本" class="headerlink" title="13.2查看版本"></a>13.2查看版本</h4><pre class=" language-bash"><code class="language-bash">nginx -v</code></pre><p>可看到版本信息，代表安装成功</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209202213615.png" alt="nginx版本" style="zoom:80%;" /><h4 id="13-3运行"><a href="#13-3运行" class="headerlink" title="13.3运行"></a>13.3运行</h4><pre class=" language-bash"><code class="language-bash">nginx</code></pre><p>如果80端口被占用</p><h4 id="13-4安装iptables服务"><a href="#13-4安装iptables服务" class="headerlink" title="13.4安装iptables服务"></a>13.4安装iptables服务</h4><p>需要通过防火墙开放对外端口。如果服务器上没有iptables服务，需要安装。如果有，则跳过。</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> iptables-servicessystemctl mask firewalld.servicesystemctl <span class="token function">enable</span> iptables.servicesystemctl <span class="token function">enable</span> ip6tables.service</code></pre><h4 id="13-5配置端口"><a href="#13-5配置端口" class="headerlink" title="13.5配置端口"></a>13.5配置端口</h4><p>进入iptables配置80端口，因为nginx默认是由80端口访问</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/sysconfig/iptables</code></pre><p>打开后，默认的配置信息如下（加粗部分为新添加的）：</p><pre class=" language-bash"><code class="language-bash">INPUT ACCEPT <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>:FORWARD ACCEPT <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>:OUTPUT ACCEPT <span class="token punctuation">[</span>6:696<span class="token punctuation">]</span>-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPTA INPUT -p tcp -m state --state NEW -m tcp --dport 30000:30999 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT</code></pre><p>后续需要开放其它端口，也是在此文件中添加修改即可！</p><p>修改完后，保存退出文件编辑。</p><pre class=" language-bash"><code class="language-bash">:wq</code></pre><h4 id="13-6重启防火墙"><a href="#13-6重启防火墙" class="headerlink" title="13.6重启防火墙"></a>13.6重启防火墙</h4><pre class=" language-bash"><code class="language-bash">systemctl restart iptables.service</code></pre><h4 id="13-7端口占用问题"><a href="#13-7端口占用问题" class="headerlink" title="13.7端口占用问题"></a>13.7端口占用问题</h4><p>1）<strong>先查看80端口被什么占用了</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token function">fuser</span> -n tcp 80</code></pre><p>2）<strong>将占用端口杀掉</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token function">kill</span> -9 进程号</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209203733586.png" alt="杀掉占用端口" style="zoom:80%;" /><h2 id="14-Nginx详细配置"><a href="#14-Nginx详细配置" class="headerlink" title="14.Nginx详细配置"></a>14.Nginx详细配置</h2><p>将 user 修改为 root //避免权限不足无法访问博客目录<br>将 root 解析路径修改为博客目录 /home/git/project/hexo-blog</p><pre class=" language-bash"><code class="language-bash">nginx -s stop //先停止nginx<span class="token function">cd</span> /usr/local/nginx-webServer/confvim nginx.conf //打开配置文件nginx -s reload //重启nginx</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209213256203.png" alt="Nginx原先配置" style="zoom:80%;" /><p>更改之后</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209213508091.png" alt="Nginx配置更新" style="zoom:80%;" /><h2 id="15-配置站点配置文件"><a href="#15-配置站点配置文件" class="headerlink" title="15.配置站点配置文件"></a>15.配置站点配置文件</h2><p>config.yml 的 deploy:</p><pre class=" language-shel"><code class="language-shel">deploy:  type: git  repo:         server: git@server_ip:/home/git/repos/hexo-blog-repo.git  branch: master</code></pre><p>server_ip : 即你购买的服务器的 IP 地址</p><p>部署</p><pre class=" language-bash"><code class="language-bash">hexo g -d</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS下安装yum</title>
      <link href="/2023/02/09/CentOS%E5%AE%89%E8%A3%85yum/"/>
      <url>/2023/02/09/CentOS%E5%AE%89%E8%A3%85yum/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS下安装yum"><a href="#CentOS下安装yum" class="headerlink" title="CentOS下安装yum"></a>CentOS下安装yum</h1><p>查看已安装的yumrpm -qa|grep yum</p><p>删除已有的yumrpm -aq|grep yum|xargs rpm -e –nodeps</p><p>下载以下安装包wget <a href="http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/pyth" target="_blank" rel="noopener">http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/pyth</a></p><h2 id="1-查看已安装的yum"><a href="#1-查看已安装的yum" class="headerlink" title="1.查看已安装的yum"></a>1.查看已安装的yum</h2><pre class=" language-vim"><code class="language-vim">rpm <span class="token operator">-</span><span class="token keyword">qa</span>|<span class="token keyword">grep</span> yum</code></pre><h2 id="2-删除已有的yum"><a href="#2-删除已有的yum" class="headerlink" title="2.删除已有的yum"></a>2.删除已有的yum</h2><pre class=" language-vim"><code class="language-vim">rpm <span class="token operator">-</span>aq|<span class="token keyword">grep</span> yum|xargs rpm <span class="token operator">-</span><span class="token keyword">e</span> <span class="token operator">-</span><span class="token operator">-</span>nodeps </code></pre><h2 id="3-下载所需安装包"><a href="#3-下载所需安装包" class="headerlink" title="3.下载所需安装包"></a>3.下载所需安装包</h2><pre class=" language-vim"><code class="language-vim">wget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span><span class="token keyword">python</span><span class="token operator">-</span><span class="token number">2.7</span><span class="token operator">.</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">89</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64<span class="token operator">.</span>rpm wget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span><span class="token keyword">python</span><span class="token operator">-</span>iniparse<span class="token operator">-</span><span class="token number">0.4</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">.</span>el7<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm wget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span>yum<span class="token operator">-</span><span class="token number">3.4</span><span class="token operator">.</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">168</span><span class="token operator">.</span>el7<span class="token operator">.</span>centos<span class="token operator">.</span>noarch<span class="token operator">.</span>rpmwget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span>yum<span class="token operator">-</span>metadata<span class="token operator">-</span>parser<span class="token operator">-</span><span class="token number">1.1</span><span class="token operator">.</span><span class="token number">4</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64<span class="token operator">.</span>rpmwget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span>yum<span class="token operator">-</span>plugin<span class="token operator">-</span>fastestmirror<span class="token operator">-</span><span class="token number">1.1</span><span class="token operator">.</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">54</span><span class="token operator">.</span>el7_8<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm</code></pre><p>如果找不到以上版本，可以到 <a href="http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/?login=from_csdn" target="_blank" rel="noopener">http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/</a> 下载最新版本</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20210505211959838.png" alt="下载最新版本"></p><h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h2><pre class=" language-vim"><code class="language-vim">rpm <span class="token operator">-</span>ivh <span class="token keyword">python</span><span class="token operator">-</span><span class="token number">2.7</span><span class="token operator">.</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">89</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64<span class="token operator">.</span>rpm <span class="token keyword">python</span><span class="token operator">-</span>iniparse<span class="token operator">-</span><span class="token number">0.4</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">.</span>el7<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm <span class="token operator">-</span><span class="token operator">-</span>nodeps <span class="token operator">-</span><span class="token operator">-</span>forcerpm <span class="token operator">-</span>ivh yum<span class="token operator">-</span>metadata<span class="token operator">-</span>parser<span class="token operator">-</span><span class="token number">1.1</span><span class="token operator">.</span><span class="token number">4</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64<span class="token operator">.</span>rpm <span class="token operator">-</span><span class="token operator">-</span>nodeps <span class="token operator">-</span><span class="token operator">-</span>forcerpm <span class="token operator">-</span>ivh yum<span class="token operator">-</span><span class="token number">3.4</span><span class="token operator">.</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">168</span><span class="token operator">.</span>el7<span class="token operator">.</span>centos<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm yum<span class="token operator">-</span>plugin<span class="token operator">-</span>fastestmirror<span class="token operator">-</span><span class="token number">1.1</span><span class="token operator">.</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">54</span><span class="token operator">.</span>el7_8<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm <span class="token operator">-</span><span class="token operator">-</span>nodeps <span class="token operator">-</span><span class="token operator">-</span>force</code></pre><h2 id="5-更改-yum源"><a href="#5-更改-yum源" class="headerlink" title="5.更改 yum源"></a>5.更改 yum源</h2><ul><li><p>到该网站 <a href="http://mirrors.163.com/.help/centos.html?login=from_csdn" target="_blank" rel="noopener">http://mirrors.163.com/.help/centos.html</a> 下载配置文件，重命名为CentOS-Base.repo</p><ul><li><p>首先备份/etc/yum.repos.d/CentOS-Base.repo</p><pre class=" language-vim"><code class="language-vim">mv <span class="token operator">/</span>etc<span class="token operator">/</span>yum<span class="token operator">.</span>repos<span class="token operator">.</span><span class="token keyword">d</span><span class="token operator">/</span>CentOS<span class="token operator">-</span>Base<span class="token operator">.</span>repo <span class="token operator">/</span>etc<span class="token operator">/</span>yum<span class="token operator">.</span>repos<span class="token operator">.</span><span class="token keyword">d</span><span class="token operator">/</span>CentOS<span class="token operator">-</span>Base<span class="token operator">.</span>repo<span class="token operator">.</span><span class="token builtin">backup</span></code></pre></li><li><p>下载对应版本repo文件， 放入/etc/yum.repos.d/（操作前请做好相应备份）</p><p><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo?login=from_csdn" target="_blank" rel="noopener">CentOS7</a></p><p><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo?login=from_csdn" target="_blank" rel="noopener">CentOS6</a></p><p><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo?login=from_csdn" target="_blank" rel="noopener">CentOS5</a></p></li><li><p>运行以下命令生成缓存</p></li></ul><pre class=" language-vim"><code class="language-vim">yum clean <span class="token keyword">all</span>yum makecache</code></pre></li><li><p>修改配置文件</p><ul><li>运行一下命令打开CentOS-Base.repo文件</li></ul><pre class=" language-vim"><code class="language-vim"><span class="token keyword">cd</span> <span class="token operator">/</span>etc<span class="token operator">/</span>yum<span class="token operator">.</span>repos<span class="token operator">.</span><span class="token keyword">d</span> <span class="token keyword">vim</span> CentOS<span class="token operator">-</span>Base<span class="token operator">.</span>repo</code></pre><blockquote><p>也可以通过Xftp7软件编辑，更加方便快捷</p></blockquote><ul><li>将以下配置更换Centos-Base.repo里的内容</li></ul><pre class=" language-vim"><code class="language-vim"># CentOS<span class="token operator">-</span>Base<span class="token operator">.</span>repo## The mirror system uses the connecting IP address of the client and the# <span class="token keyword">update</span> status of each mirror <span class="token keyword">to</span> pick mirrors that are updated <span class="token keyword">to</span> and# geographically <span class="token keyword">close</span> <span class="token keyword">to</span> the client<span class="token operator">.</span>  You should use this <span class="token keyword">for</span> CentOS updates# unless you are manually picking other mirrors<span class="token operator">.</span>## If the mirrorlist<span class="token operator">=</span> does not work <span class="token keyword">for</span> you<span class="token punctuation">,</span> <span class="token keyword">as</span> a fall back you can <span class="token keyword">try</span> the# remarked out baseurl<span class="token operator">=</span> line instead<span class="token operator">.</span>## <span class="token punctuation">[</span>base<span class="token punctuation">]</span>name<span class="token operator">=</span>CentOS<span class="token operator">-</span>$releasever <span class="token operator">-</span> Base#mirrorlist<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrorlist<span class="token operator">.</span>centos<span class="token operator">.</span>org<span class="token operator">/</span><span class="token operator">?</span>release<span class="token operator">=</span>$releasever&amp;arch<span class="token operator">=</span>$basearch&amp;repo<span class="token operator">=</span>osbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token operator">.</span>ustc<span class="token operator">.</span>edu<span class="token operator">.</span><span class="token keyword">cn</span><span class="token operator">/</span>centos<span class="token operator">/</span>$releasever<span class="token operator">/</span>os<span class="token operator">/</span>$basearch<span class="token operator">/</span>gpgcheck<span class="token operator">=</span><span class="token number">1</span>gpgkey<span class="token operator">=</span><span class="token keyword">file</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>etc<span class="token operator">/</span>pki<span class="token operator">/</span>rpm<span class="token operator">-</span>gpg<span class="token operator">/</span>RPM<span class="token operator">-</span>GPG<span class="token operator">-</span>KEY<span class="token operator">-</span>CentOS<span class="token operator">-</span><span class="token number">7</span> #released updates<span class="token punctuation">[</span>updates<span class="token punctuation">]</span>name<span class="token operator">=</span>CentOS<span class="token operator">-</span>$releasever <span class="token operator">-</span> Updates# mirrorlist<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrorlist<span class="token operator">.</span>centos<span class="token operator">.</span>org<span class="token operator">/</span><span class="token operator">?</span>release<span class="token operator">=</span>$releasever&amp;arch<span class="token operator">=</span>$basearch&amp;repo<span class="token operator">=</span>updatesbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token operator">.</span>ustc<span class="token operator">.</span>edu<span class="token operator">.</span><span class="token keyword">cn</span><span class="token operator">/</span>centos<span class="token operator">/</span>$releasever<span class="token operator">/</span>updates<span class="token operator">/</span>$basearch<span class="token operator">/</span>gpgcheck<span class="token operator">=</span><span class="token number">1</span>gpgkey<span class="token operator">=</span><span class="token keyword">file</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>etc<span class="token operator">/</span>pki<span class="token operator">/</span>rpm<span class="token operator">-</span>gpg<span class="token operator">/</span>RPM<span class="token operator">-</span>GPG<span class="token operator">-</span>KEY<span class="token operator">-</span>CentOS<span class="token operator">-</span><span class="token number">7</span> #additional packages that may <span class="token keyword">be</span> useful<span class="token punctuation">[</span>extras<span class="token punctuation">]</span>name<span class="token operator">=</span>CentOS<span class="token operator">-</span>$releasever <span class="token operator">-</span> Extras# mirrorlist<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrorlist<span class="token operator">.</span>centos<span class="token operator">.</span>org<span class="token operator">/</span><span class="token operator">?</span>release<span class="token operator">=</span>$releasever&amp;arch<span class="token operator">=</span>$basearch&amp;repo<span class="token operator">=</span>extrasbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token operator">.</span>ustc<span class="token operator">.</span>edu<span class="token operator">.</span><span class="token keyword">cn</span><span class="token operator">/</span>centos<span class="token operator">/</span>$releasever<span class="token operator">/</span>extras<span class="token operator">/</span>$basearch<span class="token operator">/</span>gpgcheck<span class="token operator">=</span><span class="token number">1</span>gpgkey<span class="token operator">=</span><span class="token keyword">file</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>etc<span class="token operator">/</span>pki<span class="token operator">/</span>rpm<span class="token operator">-</span>gpg<span class="token operator">/</span>RPM<span class="token operator">-</span>GPG<span class="token operator">-</span>KEY<span class="token operator">-</span>CentOS<span class="token operator">-</span><span class="token number">7</span> #additional packages that extend functionality of existing packages<span class="token punctuation">[</span>centosplus<span class="token punctuation">]</span>name<span class="token operator">=</span>CentOS<span class="token operator">-</span>$releasever <span class="token operator">-</span> Plus# mirrorlist<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrorlist<span class="token operator">.</span>centos<span class="token operator">.</span>org<span class="token operator">/</span><span class="token operator">?</span>release<span class="token operator">=</span>$releasever&amp;arch<span class="token operator">=</span>$basearch&amp;repo<span class="token operator">=</span>centosplusbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token operator">.</span>ustc<span class="token operator">.</span>edu<span class="token operator">.</span><span class="token keyword">cn</span><span class="token operator">/</span>centos<span class="token operator">/</span>$releasever<span class="token operator">/</span>centosplus<span class="token operator">/</span>$basearch<span class="token operator">/</span>gpgcheck<span class="token operator">=</span><span class="token number">1</span>enabled<span class="token operator">=</span><span class="token number">0</span>gpgkey<span class="token operator">=</span><span class="token keyword">file</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>etc<span class="token operator">/</span>pki<span class="token operator">/</span>rpm<span class="token operator">-</span>gpg<span class="token operator">/</span>RPM<span class="token operator">-</span>GPG<span class="token operator">-</span>KEY<span class="token operator">-</span>CentOS<span class="token operator">-</span><span class="token number">7</span></code></pre><ul><li>配置完成后更新缓存</li></ul><pre class=" language-vim"><code class="language-vim">yum clean <span class="token keyword">all</span>yum makecache</code></pre></li></ul><p>完成以上步骤就可以成功在Linux安装上yum</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>picgo图床设置与typora配置</title>
      <link href="/2023/01/11/picgo-config/"/>
      <url>/2023/01/11/picgo-config/</url>
      
        <content type="html"><![CDATA[<h1 id="picgo图床设置与typora配置"><a href="#picgo图床设置与typora配置" class="headerlink" title="picgo图床设置与typora配置"></a>picgo图床设置与typora配置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    PicGo是一个热门的图床工具，是可以自动把本地图片转换成链接的一款工具，是一款简洁容易操作的图床工具，可以支持微博、腾讯云、Github、阿里云等常用图床，功能可以说非常强大。</p><p>​    Typora是一款跨平台的Markdown编辑器软件，我们常常用它来写笔记或者博客。当使用Typora做笔记时，常常需要上传知识点截图到笔记上。截图图像为本地图像（存储在自己的电脑上，当我们把电脑本地图像进行删除或者误删时，再次打开笔记之前的截图都会显示丢，或者作为博客时，需要部署到远程仓库或服务器，而本地图片显然不能满足我们的需求。</p><p>​    使用PicGo图床工具将截图图像转换成链接或者上传到远程仓库服务器，当下次打开笔记或者查看远程博客时，编辑器会通过链接返回图像，上传后删除本地图像图像也不会丢失。下面将以配置picgo来介绍图床的搭建和配置使用以及介绍typora的图床配置。    </p><h2 id="PicGo下载"><a href="#PicGo下载" class="headerlink" title="PicGo下载"></a>PicGo下载</h2><p>Picgo最新图床工具下载链接：</p><p><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p><p>mac系统选择dmg下载，windows选择.exe下载。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111200044898.png" alt="图床下载地址"></p><p><strong>此处建议下载稳定的正式版本。</strong></p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111200208026.png" alt="下载最新稳定版本"></p><p><strong>翻到下面进行下载安装。</strong></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111200504555.png" alt="下载对应系统版本"></p><h2 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h2><p>​    下面将介绍和使用==GitHub==来作为==图床==的具体用法。由于在国内有时无法访问GitHub或者速度过慢，可以先搭个梯子。</p><h3 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h3><hr><ol><li><p>首先登陆 GitHub，点击右上角的==+==，点击新建一个**仓库（New repository)**。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111201103490.png" alt="新建仓库"></p></li><li><p>进入页面，设置仓库名称， 选择仓库类型为==公开（Public）==， 由于私有仓库只有自己能够访问，上传图像后无法显示，所以必须时公有仓库。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111201536456.png" alt="设置远程仓库"></p></li><li><p>创建远程仓库后，点击右上角头像，进入设置。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111201701845.png" alt="进入设置"></p></li><li><p>接下来需要在 github 上生成一个token以便于 PicGo  根据令牌信息上传图像到我们的仓库。进入设置后，划到最下面左边栏中选择==开发人员设置（Developer  settings）==进入页面就可以看到 Personal access tokens。</p></li><li><p>点击==Generate new token== 创建一个新token，这里选择classic模式。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111202739291.png" alt="Generate选项"></p></li><li><p>生成令牌，过程如图，选择完后划到最下面按下==Generate token==，即可生成令牌。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111203414659.png" alt="生成令牌过程"></p></li><li><p>生成token如图所示，请注意蓝色框提醒==务必立即复制您的个人访问令牌。你将无法再看到它==，请先将生成的token复制保存下来，退出此页面后将<strong>再也看不到该token</strong>。</p></li></ol><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111203754137.png" alt="复制令牌"></p><h3 id="PicGo配置与使用"><a href="#PicGo配置与使用" class="headerlink" title="PicGo配置与使用"></a>PicGo配置与使用</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><hr><p>​    打开 PicGo，进入github设置</p><ul><li>仓库名格式： <code>用户名/仓库名</code>，例如<code>reasonllh/picgoIMG</code></li><li>分支名：main</li><li>token令牌：刚刚从复制保存的token令牌粘贴到此处</li><li>可以将此设置为默认图床</li></ul><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111204300355.png" alt="picGo图床设置"></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>​    picgo的图片上传方式就很多了，可以将图片拖拽到此处，也可以上传图片上传，更多的用法可以参考官方文档：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230210214242635.png" alt="picgo图片上传区" style="zoom:67%;" /><hr><h2 id="Typora图床设置"><a href="#Typora图床设置" class="headerlink" title="Typora图床设置"></a>Typora图床设置</h2><p>​    相信很多小伙伴也跟Reason一样有写博客的需求，而typora是一款很多程序员使用的编写markdown格式的软件，下面将介绍typora的图床有关配置。</p><ol><li>打开<code>Typora</code>，点击左上角菜单栏进入==偏好设置==。</li><li>选择 <code>图像</code> ，在<code>上传服务</code>一栏中选择<code>PicGo</code>。注意如果是windows的话还需要选择PicGo.exe的路径，最后点击<code>验证图片上传选项</code>显示成功即Typora配置图床工具完成。</li></ol><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111205309304.png" alt="typora设置"></p><ol><li><p>将图片放入Typora笔记中，右击图像选择==上传图片==即可上传到远程仓库。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111205714617.png" alt="上传图片选项">               </p></li></ol><p>​                                                            </p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picGo </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sin</title>
      <link href="/2023/01/11/sin/"/>
      <url>/2023/01/11/sin/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>about hexo</title>
      <link href="/2023/01/11/about%20hexo/"/>
      <url>/2023/01/11/about%20hexo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">blinkfox/hexo-theme-matery：一个漂亮的hexo博客主题，具有材料设计和响应式设计而成的全面、美观的Hexo主题。国内访问：http://blinkfox.com (github.com)</a></p><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-3" target="_blank" rel="noopener">Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐 (blinkfox.github.io)</a></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111222235606.png" alt="image-20230111222235606"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex弹性盒子</title>
      <link href="/2023/01/07/M1D7/"/>
      <url>/2023/01/07/M1D7/</url>
      
        <content type="html"><![CDATA[<p>2023.1.7</p><p>[HTML学习](<a href="https://developer.mozilla.org/en-US/docs/Web/HTML" target="_blank" rel="noopener">HTML：超文本标记语言|多核 (mozilla.org)</a>)</p><h1 id="Flex弹性盒子学习"><a href="#Flex弹性盒子学习" class="headerlink" title="Flex弹性盒子学习"></a><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex弹性盒子学习</a></h1><h2 id="一、弹性盒子介绍"><a href="#一、弹性盒子介绍" class="headerlink" title="一、弹性盒子介绍"></a>一、弹性盒子介绍</h2><p>​    采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230108152912342.png" alt="Flex 容器" style="zoom:80%;" /><p>​    容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<strong>项目默认沿主轴排列</strong>。</p><p>​    主轴的开始位置（与边框的交叉点）叫==main start==，结束位置叫做==main end==；</p><p>​    交叉轴的开始位置叫==cross start==，结束位置叫==cross end==。</p><p>​    单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="二、容器的属性"><a href="#二、容器的属性" class="headerlink" title="二、容器的属性"></a>二、容器的属性</h2><ul><li><strong>flex-direction:row | row-reverse | column | column-reverse;</strong></li><li><strong>flex-wrap:nowrap | wrap | wrap-reverse;</strong></li><li><strong>flex-flow: flex-direction || flex-wrap;</strong></li><li><strong>justify-content:flex-start | flex-end | center | space-between | space-around;</strong></li><li><strong>align-items:flex-start | flex-end | center | baseline | stretch;</strong></li><li><strong>align-content:flex-start | flex-end | center | space-between | space-around | stretch;</strong></li></ul><p><strong>2.1flex-direction主轴的方向（即项目的排列方向）</strong></p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><p><strong>2.2flex-wrap换行取值</strong></p><p>​    默认情况下，项目都排在一条线（又称”轴线”）上。如果一条轴线排不下，如何换行。</p><ul><li><p><code>nowrap</code>（默认）：不换行。</p></li><li><p><code>wrap</code>：换行，第一行在上方。</p></li><li><p><code>wrap-reverse</code>：换行，第一行在下方。</p></li></ul><p><strong>2.3<code>flex-flow</code>=<code>flex-direction</code>+<code>flex-wrap</code>，默认值为<code>row nowrap</code></strong></p><p><strong>2.4justify-content项目在主轴上的对齐方式</strong></p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230108154405854.png" alt="justify-content项目在主轴上的对齐方式" style="zoom:50%;" /><p><strong>2.5align-items项目在交叉轴上如何对齐</strong></p><p>​    具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230108154638899.png" alt="align-items项目在交叉轴上对齐方式" style="zoom:50%;" /><p><strong>2.6align-content定义了多根轴线的对齐方式</strong></p><p>​    如果项目只有一根轴线，该属性不起作用。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230108155228637.png" alt="align-content在多根轴线上的对齐方式" style="zoom:50%;" /><h2 id="三、项目的属性"><a href="#三、项目的属性" class="headerlink" title="三、项目的属性"></a>三、项目的属性</h2><p>以下6个属性设置在项目上</p><ul><li><code>order:&lt;integer&gt;;/* default 0 */</code></li><li><code>flex-grow</code>:<number>;/* default 0 */</li><li><code>flex-shrink</code>:<number>; /* default 1 */</li><li><code>flex-basis</code>:<length> | auto; /* default auto */</li><li><code>flex</code>:none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]</li><li><code>align-self</code>:auto | flex-start | flex-end | center | baseline | stretch;</li></ul><p><strong>3.1order项目的排列顺序</strong></p><p>​    数值越小，排列越靠前，默认为0。</p><p><strong>3.2flex-grow项目的放大比例</strong></p><p>​    默认为<code>0</code>，即如果存在剩余空间，也不放大</p><p>​    如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。</p><p>​    如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><p><strong>3.3flex-shrink项目的缩小比例</strong></p><p>​    默认为1，即如果空间不足，该项目将缩小。</p><p>​    如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。</p><p>​    如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p><p><strong>3.4flex-basis在分配多余空间之前，项目占据的主轴空间</strong></p><p>​    浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><p>​    它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><p><strong>3.5 flex=<code>flex-grow</code>+<code>flex-shrink</code> + <code>flex-basis</code></strong></p><p>​    默认值为<code>0 1 auto</code>。后两个属性可选。</p><p>​    该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>​    建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><p><strong>3.6 align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</strong></p><p>​    <code>align-self</code>属性默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/bg2015071016.png" alt="align-self允许单个项目有不一样的对齐方式" style="zoom:50%;" /><p>​    该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
